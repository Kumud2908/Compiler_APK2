C/C++ Syntax Analyzer with AST
==============================

Token: #include <stdio.h>   Type: PREPROCESSOR   
Token: union                Type: KEYWORD        
Token: Data                 Type: IDENTIFIER     
Token: {                    Type: LBRACE         
Token: int                  Type: KEYWORD        
Token: i                    Type: IDENTIFIER     
Token: ;                    Type: SEMICOLON      
Token: float                Type: KEYWORD        
Token: f                    Type: IDENTIFIER     
Token: ;                    Type: SEMICOLON      
Token: char                 Type: KEYWORD        
Token: c                    Type: IDENTIFIER     
Token: ;                    Type: SEMICOLON      
Token: }                    Type: RBRACE         
Token: ;                    Type: SEMICOLON      
Token: int                  Type: KEYWORD        
Token: main                 Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: )                    Type: RPAREN         
Token: {                    Type: LBRACE         
Token: union                Type: KEYWORD        
Token: Data                 Type: TYPEDEF_NAME   
Token: d                    Type: IDENTIFIER     
Token: ;                    Type: SEMICOLON      
Token: d                    Type: IDENTIFIER     
Token: .                    Type: DOT            
Token: i                    Type: IDENTIFIER     
Token: =                    Type: ASSIGN         
Token: 65                   Type: INTEGER_CONSTANT
Token: ;                    Type: SEMICOLON      
Token: printf               Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: "i = %d\n"           Type: STRING_LITERAL 
Token: ,                    Type: COMMA          
Token: d                    Type: IDENTIFIER     
Token: .                    Type: DOT            
Token: i                    Type: IDENTIFIER     
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: d                    Type: IDENTIFIER     
Token: .                    Type: DOT            
Token: c                    Type: IDENTIFIER     
Token: =                    Type: ASSIGN         
Token: 'A'                  Type: CHARACTER_CONSTANT
Token: ;                    Type: SEMICOLON      
Token: printf               Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: "c = %c, i = %d\n"   Type: STRING_LITERAL 
Token: ,                    Type: COMMA          
Token: d                    Type: IDENTIFIER     
Token: .                    Type: DOT            
Token: c                    Type: IDENTIFIER     
Token: ,                    Type: COMMA          
Token: d                    Type: IDENTIFIER     
Token: .                    Type: DOT            
Token: i                    Type: IDENTIFIER     
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: d                    Type: IDENTIFIER     
Token: .                    Type: DOT            
Token: f                    Type: IDENTIFIER     
Token: =                    Type: ASSIGN         
Token: 3.14                 Type: FLOAT_CONSTANT 
Token: ;                    Type: SEMICOLON      
Token: printf               Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: "f = %.2f, i = %d\n" Type: STRING_LITERAL 
Token: ,                    Type: COMMA          
Token: d                    Type: IDENTIFIER     
Token: .                    Type: DOT            
Token: f                    Type: IDENTIFIER     
Token: ,                    Type: COMMA          
Token: d                    Type: IDENTIFIER     
Token: .                    Type: DOT            
Token: i                    Type: IDENTIFIER     
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: return               Type: KEYWORD        
Token: 0                    Type: INTEGER_CONSTANT
Token: ;                    Type: SEMICOLON      
Token: }                    Type: RBRACE         

=== PARSING SUCCESSFUL ===

=== SEMANTIC ANALYSIS ===
=== SEMANTIC ANALYSIS STARTED ===
Line 18: WARNING: Implicit type conversion in assignment: 'double' to 'int'
=== SEMANTIC ANALYSIS COMPLETED ===
Found 0 semantic error(s)
Found 1 warning(s)

=== SYMBOL TABLE (ACTIVE SCOPES) ===
Scope 0:
  function 'main' : int (scope: 0, line: 22) [has_return]
 (scope: 0, line: 22) [has_return]
  union 'Data' : union (scope: 0, line: 7)
    member 'i' : int (scope: 0, line: 0)
 (scope: 0, line: 0)
    member 'f' : int (scope: 0, line: 0)
 (scope: 0, line: 0)
    member 'c' : int (scope: 0, line: 0)
 (scope: 0, line: 0)
 (scope: 0, line: 7)
    Members:
    member 'i' : int (scope: 0, line: 0)
 (scope: 0, line: 0)
    member 'f' : int (scope: 0, line: 0)
 (scope: 0, line: 0)
    member 'c' : int (scope: 0, line: 0)
 (scope: 0, line: 0)
  constant 'NULL' : void* (scope: 0, line: 0)
 (scope: 0, line: 0)

 Semantic analysis passed with no errors.

=== CODE GENERATION ===

=== THREE ADDRESS CODE ===
main:
    t0 = &d
    *t0 = 65
    param "i = %d\n"
    t1 = &d
    t2 = *t1
    param t2
    t3 = call printf, 2
    t4 = &d
    *t4 = 'A'
    param "c = %c, i = %d\n"
    t5 = &d
    t6 = *t5
    param t6
    t7 = &d
    t8 = *t7
    param t8
    t9 = call printf, 3
    t10 = &d
    *t10 = 3.14
    param "f = %.2f, i = %d\n"
    t11 = &d
    t12 = *t11
    param t12
    t13 = &d
    t14 = *t13
    param t14
    t15 = call printf, 3
    return 0

Total instructions: 29

=== ABSTRACT SYNTAX TREE ===
TranslationUnit :  (line 1)
  Preprocessor : #include <stdio.h> (line 1)
  Declaration :  (line 7)
    DeclarationSpecifiers :  (line 7)
      StructOrUnionSpecifier :  (line 7)
        StructOrUnion : union (line 7)
        Identifier : Data (line 7)
        StructDeclarationList :  (line 4)
          StructDeclaration :  (line 4)
            TypeSpecifier : int (line 4)
            StructDeclaratorList :  (line 4)
              DirectDeclarator : i (line 4)
          StructDeclaration :  (line 5)
            TypeSpecifier : float (line 5)
            StructDeclaratorList :  (line 5)
              DirectDeclarator : f (line 5)
          StructDeclaration :  (line 6)
            TypeSpecifier : char (line 6)
            StructDeclaratorList :  (line 6)
              DirectDeclarator : c (line 6)
  FunctionDefinition :  (line 22)
    DeclarationSpecifiers :  (line 9)
      TypeSpecifier : int (line 9)
    FunctionDeclarator :  (line 9)
      DirectDeclarator : main (line 9)
    CompoundStatement :  (line 22)
      BlockItemList :  (line 10)
        BlockItem :  (line 10)
          Declaration :  (line 10)
            DeclarationSpecifiers :  (line 10)
              StructOrUnionSpecifier :  (line 10)
                StructOrUnion : union (line 10)
                Identifier : Data (line 10)
            InitDeclaratorList :  (line 10)
              InitDeclarator :  (line 10)
                DirectDeclarator : d (line 10)
        BlockItem :  (line 12)
          ExpressionStatement :  (line 12)
            AssignmentExpression : = (line 12)
              MemberAccess : . (line 12)
                Identifier : d (line 12)
                Identifier : i (line 12)
              Constant : 65 (line 12)
        BlockItem :  (line 13)
          ExpressionStatement :  (line 13)
            FunctionCall :  (line 13)
              Identifier : printf (line 13)
              ArgumentList :  (line 13)
                StringLiteral : "i = %d\n" (line 13)
                MemberAccess : . (line 13)
                  Identifier : d (line 13)
                  Identifier : i (line 13)
        BlockItem :  (line 15)
          ExpressionStatement :  (line 15)
            AssignmentExpression : = (line 15)
              MemberAccess : . (line 15)
                Identifier : d (line 15)
                Identifier : c (line 15)
              Constant : 'A' (line 15)
        BlockItem :  (line 16)
          ExpressionStatement :  (line 16)
            FunctionCall :  (line 16)
              Identifier : printf (line 16)
              ArgumentList :  (line 16)
                StringLiteral : "c = %c, i = %d\n" (line 16)
                MemberAccess : . (line 16)
                  Identifier : d (line 16)
                  Identifier : c (line 16)
                MemberAccess : . (line 16)
                  Identifier : d (line 16)
                  Identifier : i (line 16)
        BlockItem :  (line 18)
          ExpressionStatement :  (line 18)
            AssignmentExpression : = (line 18)
              MemberAccess : . (line 18)
                Identifier : d (line 18)
                Identifier : f (line 18)
              Constant : 3.14 (line 18)
        BlockItem :  (line 19)
          ExpressionStatement :  (line 19)
            FunctionCall :  (line 19)
              Identifier : printf (line 19)
              ArgumentList :  (line 19)
                StringLiteral : "f = %.2f, i = %d\n" (line 19)
                MemberAccess : . (line 19)
                  Identifier : d (line 19)
                  Identifier : f (line 19)
                MemberAccess : . (line 19)
                  Identifier : d (line 19)
                  Identifier : i (line 19)
        BlockItem :  (line 21)
          ReturnStatement :  (line 21)
            Constant : 0 (line 21)

AST DOT file generated: ast.dot
TAC file generated: output.tac

=== MIPS ASSEMBLY GENERATION ===

=== MIPS ASSEMBLY CODE ===
    # ==============================================
    #   MIPS Assembly Code
    #   Generated from Three-Address Code
    # ==============================================

.data
.align 2
str_2: .asciiz "f = %.2f, i = %d\n"
.align 2
str_1: .asciiz "c = %c, i = %d\n"
.align 2
str_0: .asciiz "i = %d\n"
.align 2
newline: .asciiz "\n"
.align 2
var_d: .space 400

.text
.globl main


    # Function: main
main:
    # Reserve stack space for register spills
    addi $sp, $sp, -256
    la $t0, var_d
    li $t1, 65
    sw $t1, 0($t0)
    la $s0, str_0
    # Save string param str_0 to $s0
    la $t1, var_d
    lw $t2, 0($t1)
    move $s1, $t2
    # Save param t2 to $s1
    # Call printf
    li $v0, 11
    li $a0, 105
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 61
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    # Print integer
    li $v0, 1
    move $a0, $s1
    syscall
    li $v0, 11
    li $a0, 10
    syscall
    la $t0, var_d
    li $t1, 65
    sw $t1, 0($t0)
    la $s2, str_1
    # Save string param str_1 to $s2
    la $t1, var_d
    lw $t2, 0($t1)
    move $s3, $t2
    # Save param t6 to $s3
    la $t1, var_d
    lw $t2, 0($t1)
    move $s4, $t2
    # Save param t8 to $s4
    # Call printf
    li $v0, 11
    li $a0, 99
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 61
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    # Print character
    li $v0, 11
    move $a0, $s3
    syscall
    li $v0, 11
    li $a0, 44
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 105
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 61
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    # Print integer
    li $v0, 1
    move $a0, $s4
    syscall
    li $v0, 11
    li $a0, 10
    syscall
    la $t0, var_d
    sw $t1, 0($t0)
    la $s5, str_2
    # Save string param str_2 to $s5
    la $t2, var_d
    lw $t3, 0($t2)
    move $s6, $t3
    # Save param t12 to $s6
    la $t2, var_d
    lw $t3, 0($t2)
    move $s7, $t3
    # Save param t14 to $s7
    # Call printf
    li $v0, 11
    li $a0, 102
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 61
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    # Print float
    # Print float
    li $v0, 2
    mtc1 $s6, $f12
    syscall
    li $v0, 11
    li $a0, 44
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 105
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 61
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    # Print integer
    li $v0, 1
    move $a0, $s7
    syscall
    li $v0, 11
    li $a0, 10
    syscall
    li $v0, 0
    # Restore stack and exit program
    addi $sp, $sp, 256
    li $v0, 10
    syscall

MIPS file generated: output.s

==================================================
COMPILATION SUCCESSFUL
==================================================
