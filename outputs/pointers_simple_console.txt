C/C++ Syntax Analyzer with AST
==============================

Token: #include <stdio.h>   Type: PREPROCESSOR   
Token: #include <stdlib.h>  Type: PREPROCESSOR   
Token: #include <string.h>  Type: PREPROCESSOR   
Token: void                 Type: KEYWORD        
Token: testcase1            Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: )                    Type: RPAREN         
Token: {                    Type: LBRACE         
Token: int                  Type: KEYWORD        
Token: arr                  Type: IDENTIFIER     
Token: [                    Type: LBRACKET       
Token: ]                    Type: RBRACKET       
Token: =                    Type: ASSIGN         
Token: {                    Type: LBRACE         
Token: 10                   Type: INTEGER_CONSTANT
Token: ,                    Type: COMMA          
Token: 20                   Type: INTEGER_CONSTANT
Token: ,                    Type: COMMA          
Token: 30                   Type: INTEGER_CONSTANT
Token: ,                    Type: COMMA          
Token: 40                   Type: INTEGER_CONSTANT
Token: ,                    Type: COMMA          
Token: 50                   Type: INTEGER_CONSTANT
Token: }                    Type: RBRACE         
Token: ;                    Type: SEMICOLON      
Token: int                  Type: KEYWORD        
Token: *                    Type: ARITHMETIC_OP  
Token: p                    Type: IDENTIFIER     
Token: =                    Type: ASSIGN         
Token: arr                  Type: IDENTIFIER     
Token: ;                    Type: SEMICOLON      
Token: printf               Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: "\nTESTCASE 1: Pointer Arithmetic\n" Type: STRING_LITERAL 
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: printf               Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: "*(p+2) = %d\n"      Type: STRING_LITERAL 
Token: ,                    Type: COMMA          
Token: *                    Type: ARITHMETIC_OP  
Token: (                    Type: LPAREN         
Token: p                    Type: IDENTIFIER     
Token: +                    Type: ARITHMETIC_OP  
Token: 2                    Type: INTEGER_CONSTANT
Token: )                    Type: RPAREN         
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: p                    Type: IDENTIFIER     
Token: ++                   Type: POSTFIX_OP     
Token: ;                    Type: SEMICOLON      
Token: printf               Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: "*p after p++ = %d\n" Type: STRING_LITERAL 
Token: ,                    Type: COMMA          
Token: *                    Type: ARITHMETIC_OP  
Token: p                    Type: IDENTIFIER     
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: }                    Type: RBRACE         
Token: void                 Type: KEYWORD        
Token: testcase2            Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: )                    Type: RPAREN         
Token: {                    Type: LBRACE         
Token: int                  Type: KEYWORD        
Token: a                    Type: IDENTIFIER     
Token: =                    Type: ASSIGN         
Token: 100                  Type: INTEGER_CONSTANT
Token: ;                    Type: SEMICOLON      
Token: int                  Type: KEYWORD        
Token: *                    Type: ARITHMETIC_OP  
Token: p                    Type: IDENTIFIER     
Token: =                    Type: ASSIGN         
Token: &                    Type: BITWISE_OP     
Token: a                    Type: IDENTIFIER     
Token: ;                    Type: SEMICOLON      
Token: int                  Type: KEYWORD        
Token: *                    Type: ARITHMETIC_OP  
Token: *                    Type: ARITHMETIC_OP  
Token: pp                   Type: IDENTIFIER     
Token: =                    Type: ASSIGN         
Token: &                    Type: BITWISE_OP     
Token: p                    Type: IDENTIFIER     
Token: ;                    Type: SEMICOLON      
Token: printf               Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: "\nTESTCASE 2: Pointer to Pointer\n" Type: STRING_LITERAL 
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: printf               Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: "a = %d\n"           Type: STRING_LITERAL 
Token: ,                    Type: COMMA          
Token: a                    Type: IDENTIFIER     
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: printf               Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: "*p = %d\n"          Type: STRING_LITERAL 
Token: ,                    Type: COMMA          
Token: *                    Type: ARITHMETIC_OP  
Token: p                    Type: IDENTIFIER     
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: printf               Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: "**pp = %d\n"        Type: STRING_LITERAL 
Token: ,                    Type: COMMA          
Token: *                    Type: ARITHMETIC_OP  
Token: *                    Type: ARITHMETIC_OP  
Token: pp                   Type: IDENTIFIER     
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: }                    Type: RBRACE         
Token: void                 Type: KEYWORD        
Token: testcase3            Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: )                    Type: RPAREN         
Token: {                    Type: LBRACE         
Token: char                 Type: KEYWORD        
Token: *                    Type: ARITHMETIC_OP  
Token: names                Type: IDENTIFIER     
Token: [                    Type: LBRACKET       
Token: ]                    Type: RBRACKET       
Token: =                    Type: ASSIGN         
Token: {                    Type: LBRACE         
Token: "Alice"              Type: STRING_LITERAL 
Token: ,                    Type: COMMA          
Token: "Bob"                Type: STRING_LITERAL 
Token: ,                    Type: COMMA          
Token: "Charlie"            Type: STRING_LITERAL 
Token: }                    Type: RBRACE         
Token: ;                    Type: SEMICOLON      
Token: printf               Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: "\nTESTCASE 3: Array of Pointers\n" Type: STRING_LITERAL 
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: for                  Type: KEYWORD        
Token: (                    Type: LPAREN         
Token: int                  Type: KEYWORD        
Token: i                    Type: IDENTIFIER     
Token: =                    Type: ASSIGN         
Token: 0                    Type: INTEGER_CONSTANT
Token: ;                    Type: SEMICOLON      
Token: i                    Type: IDENTIFIER     
Token: <                    Type: RELATIONAL_OP  
Token: 3                    Type: INTEGER_CONSTANT
Token: ;                    Type: SEMICOLON      
Token: i                    Type: IDENTIFIER     
Token: ++                   Type: POSTFIX_OP     
Token: )                    Type: RPAREN         
Token: {                    Type: LBRACE         
Token: printf               Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: "names[%d] = %s\n"   Type: STRING_LITERAL 
Token: ,                    Type: COMMA          
Token: i                    Type: IDENTIFIER     
Token: ,                    Type: COMMA          
Token: names                Type: IDENTIFIER     
Token: [                    Type: LBRACKET       
Token: i                    Type: IDENTIFIER     
Token: ]                    Type: RBRACKET       
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: }                    Type: RBRACE         
Token: }                    Type: RBRACE         
Token: int                  Type: KEYWORD        
Token: add                  Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: int                  Type: KEYWORD        
Token: a                    Type: IDENTIFIER     
Token: ,                    Type: COMMA          
Token: int                  Type: KEYWORD        
Token: b                    Type: IDENTIFIER     
Token: )                    Type: RPAREN         
Token: {                    Type: LBRACE         
Token: return               Type: KEYWORD        
Token: a                    Type: IDENTIFIER     
Token: +                    Type: ARITHMETIC_OP  
Token: b                    Type: IDENTIFIER     
Token: ;                    Type: SEMICOLON      
Token: }                    Type: RBRACE         
Token: void                 Type: KEYWORD        
Token: testcase4            Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: )                    Type: RPAREN         
Token: {                    Type: LBRACE         
Token: int                  Type: KEYWORD        
Token: (                    Type: LPAREN         
Token: *                    Type: ARITHMETIC_OP  
Token: fp                   Type: IDENTIFIER     
Token: )                    Type: RPAREN         
Token: (                    Type: LPAREN         
Token: int                  Type: KEYWORD        
Token: ,                    Type: COMMA          
Token: int                  Type: KEYWORD        
Token: )                    Type: RPAREN         
Token: =                    Type: ASSIGN         
Token: add                  Type: IDENTIFIER     
Token: ;                    Type: SEMICOLON      
Token: printf               Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: "\nTESTCASE 4: Pointer to Function\n" Type: STRING_LITERAL 
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: printf               Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: "add(5,7) using fp = %d\n" Type: STRING_LITERAL 
Token: ,                    Type: COMMA          
Token: fp                   Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: 5                    Type: INTEGER_CONSTANT
Token: ,                    Type: COMMA          
Token: 7                    Type: INTEGER_CONSTANT
Token: )                    Type: RPAREN         
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: }                    Type: RBRACE         
Token: int                  Type: KEYWORD        
Token: *                    Type: ARITHMETIC_OP  
Token: getDanglingPtr       Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: )                    Type: RPAREN         
Token: {                    Type: LBRACE         
Token: int                  Type: KEYWORD        
Token: x                    Type: IDENTIFIER     
Token: =                    Type: ASSIGN         
Token: 50                   Type: INTEGER_CONSTANT
Token: ;                    Type: SEMICOLON      
Token: return               Type: KEYWORD        
Token: &                    Type: BITWISE_OP     
Token: x                    Type: IDENTIFIER     
Token: ;                    Type: SEMICOLON      
Token: }                    Type: RBRACE         
Token: void                 Type: KEYWORD        
Token: testcase7            Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: )                    Type: RPAREN         
Token: {                    Type: LBRACE         
Token: printf               Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: "\nTESTCASE 7: Dangling Pointer (unsafe)\n" Type: STRING_LITERAL 
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: int                  Type: KEYWORD        
Token: *                    Type: ARITHMETIC_OP  
Token: dp                   Type: IDENTIFIER     
Token: =                    Type: ASSIGN         
Token: getDanglingPtr       Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: printf               Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: "Dangling pointer value (undefined) = %d\n" Type: STRING_LITERAL 
Token: ,                    Type: COMMA          
Token: *                    Type: ARITHMETIC_OP  
Token: dp                   Type: IDENTIFIER     
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: }                    Type: RBRACE         
Token: void                 Type: KEYWORD        
Token: testcase8            Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: )                    Type: RPAREN         
Token: {                    Type: LBRACE         
Token: printf               Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: "\nTESTCASE 8: Double Free (dangerous)\n" Type: STRING_LITERAL 
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: int                  Type: KEYWORD        
Token: *                    Type: ARITHMETIC_OP  
Token: ptr                  Type: IDENTIFIER     
Token: =                    Type: ASSIGN         
Token: malloc               Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: 4                    Type: INTEGER_CONSTANT
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: *                    Type: ARITHMETIC_OP  
Token: ptr                  Type: IDENTIFIER     
Token: =                    Type: ASSIGN         
Token: 999                  Type: INTEGER_CONSTANT
Token: ;                    Type: SEMICOLON      
Token: printf               Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: "Value = %d\n"       Type: STRING_LITERAL 
Token: ,                    Type: COMMA          
Token: *                    Type: ARITHMETIC_OP  
Token: ptr                  Type: IDENTIFIER     
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: free                 Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: ptr                  Type: IDENTIFIER     
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: printf               Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: "Freed once\n"       Type: STRING_LITERAL 
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: printf               Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: "Double free avoided (commented out)\n" Type: STRING_LITERAL 
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: }                    Type: RBRACE         
Token: void                 Type: KEYWORD        
Token: swap                 Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: int                  Type: KEYWORD        
Token: *                    Type: ARITHMETIC_OP  
Token: x                    Type: IDENTIFIER     
Token: ,                    Type: COMMA          
Token: int                  Type: KEYWORD        
Token: *                    Type: ARITHMETIC_OP  
Token: y                    Type: IDENTIFIER     
Token: )                    Type: RPAREN         
Token: {                    Type: LBRACE         
Token: int                  Type: KEYWORD        
Token: temp                 Type: IDENTIFIER     
Token: =                    Type: ASSIGN         
Token: *                    Type: ARITHMETIC_OP  
Token: x                    Type: IDENTIFIER     
Token: ;                    Type: SEMICOLON      
Token: *                    Type: ARITHMETIC_OP  
Token: x                    Type: IDENTIFIER     
Token: =                    Type: ASSIGN         
Token: *                    Type: ARITHMETIC_OP  
Token: y                    Type: IDENTIFIER     
Token: ;                    Type: SEMICOLON      
Token: *                    Type: ARITHMETIC_OP  
Token: y                    Type: IDENTIFIER     
Token: =                    Type: ASSIGN         
Token: temp                 Type: IDENTIFIER     
Token: ;                    Type: SEMICOLON      
Token: }                    Type: RBRACE         
Token: void                 Type: KEYWORD        
Token: testcase9            Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: )                    Type: RPAREN         
Token: {                    Type: LBRACE         
Token: int                  Type: KEYWORD        
Token: a                    Type: IDENTIFIER     
Token: =                    Type: ASSIGN         
Token: 5                    Type: INTEGER_CONSTANT
Token: ,                    Type: COMMA          
Token: b                    Type: IDENTIFIER     
Token: =                    Type: ASSIGN         
Token: 10                   Type: INTEGER_CONSTANT
Token: ;                    Type: SEMICOLON      
Token: printf               Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: "\nTESTCASE 9: Swap using pointers\n" Type: STRING_LITERAL 
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: printf               Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: "Before: a=%d b=%d\n" Type: STRING_LITERAL 
Token: ,                    Type: COMMA          
Token: a                    Type: IDENTIFIER     
Token: ,                    Type: COMMA          
Token: b                    Type: IDENTIFIER     
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: swap                 Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: &                    Type: BITWISE_OP     
Token: a                    Type: IDENTIFIER     
Token: ,                    Type: COMMA          
Token: &                    Type: BITWISE_OP     
Token: b                    Type: IDENTIFIER     
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: printf               Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: "After : a=%d b=%d\n" Type: STRING_LITERAL 
Token: ,                    Type: COMMA          
Token: a                    Type: IDENTIFIER     
Token: ,                    Type: COMMA          
Token: b                    Type: IDENTIFIER     
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: }                    Type: RBRACE         
Token: int                  Type: KEYWORD        
Token: main                 Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: )                    Type: RPAREN         
Token: {                    Type: LBRACE         
Token: testcase1            Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: testcase2            Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: testcase3            Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: testcase4            Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: testcase7            Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: testcase8            Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: testcase9            Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: return               Type: KEYWORD        
Token: 0                    Type: INTEGER_CONSTANT
Token: ;                    Type: SEMICOLON      
Token: }                    Type: RBRACE         

=== PARSING SUCCESSFUL ===

=== SEMANTIC ANALYSIS ===
=== SEMANTIC ANALYSIS STARTED ===
Line 101: WARNING: Implicit type conversion in initialization: 'int' to 'int*'
Line 101: WARNING: Implicit type conversion in initialization: 'int' to 'int*'
=== SEMANTIC ANALYSIS COMPLETED ===
Found 0 semantic error(s)
Found 2 warning(s)

=== SYMBOL TABLE (ACTIVE SCOPES) ===
Scope 0:
  function 'testcase9' : void (scope: 0, line: 138)
 (scope: 0, line: 138)
  function 'testcase8' : void (scope: 0, line: 120)
 (scope: 0, line: 120)
  function 'main' : int (scope: 0, line: 170) [has_return]
 (scope: 0, line: 170) [has_return]
  function 'testcase7' : void (scope: 0, line: 103)
 (scope: 0, line: 103)
  function 'swap' : void(int*, int*) (scope: 0, line: 129)
    parameter 'x' : int* (scope: 0, line: 0)
 (scope: 0, line: 0)
    parameter 'y' : int* (scope: 0, line: 0)
 (scope: 0, line: 0)
 (int* x, int* y) (scope: 0, line: 129)
  function 'add' : int(int, int) (scope: 0, line: 48) [has_return]
    parameter 'a' : int (scope: 0, line: 0)
 (scope: 0, line: 0)
    parameter 'b' : int (scope: 0, line: 0)
 (scope: 0, line: 0)
 (int a, int b) (scope: 0, line: 48) [has_return]
  function 'getDanglingPtr' : int (scope: 0, line: 97) [has_return]
 (scope: 0, line: 97) [has_return]
  function 'testcase3' : void (scope: 0, line: 43)
 (scope: 0, line: 43)
  function 'testcase4' : void (scope: 0, line: 55)
 (scope: 0, line: 55)
  function 'testcase2' : void (scope: 0, line: 31)
 (scope: 0, line: 31)
  function 'testcase1' : void (scope: 0, line: 17)
 (scope: 0, line: 17)
  constant 'NULL' : void* (scope: 0, line: 0)
 (scope: 0, line: 0)

 Semantic analysis passed with no errors.

=== CODE GENERATION ===

=== THREE ADDRESS CODE ===
testcase1:
    t0 = &arr
    *t0 = 10
    t1 = t0 + 4
    *t1 = 20
    t2 = t0 + 8
    *t2 = 30
    t3 = t0 + 12
    *t3 = 40
    t4 = t0 + 16
    *t4 = 50
    p = arr
    param "\nTESTCASE 1: Pointer Arithmetic\n"
    t5 = call printf, 1
    param "*(p+2) = %d\n"
    t8 = 2 * 4
    t7 = p + t8
    t6 = *t7
    param t6
    t9 = call printf, 2
    t10 = p
    p = p + 1
    param "*p after p++ = %d\n"
    t11 = *p
    param t11
    t12 = call printf, 2
    return
testcase2:
    a[0] = 100
    t13 = &a
    p[0] = t13
    t14 = &p
    pp = t14
    param "\nTESTCASE 2: Pointer to Pointer\n"
    t15 = call printf, 1
    param "a = %d\n"
    t16 = a[0]
    param t16
    t17 = call printf, 2
    param "*p = %d\n"
    t19 = p[0]
    t18 = *t19
    param t18
    t20 = call printf, 2
    param "**pp = %d\n"
    t22 = *pp
    t21 = *t22
    param t21
    t23 = call printf, 2
    return
testcase3:
    names = 
    param "\nTESTCASE 3: Array of Pointers\n"
    t24 = call printf, 1
    i = 0
L0:
    t25 = i < 3
    ifFalse t25 goto L1
    param "names[%d] = %s\n"
    param i
    t26 = i * 1
    t27 = &names
    t28 = t27 + t26
    t29 = *t28
    param t29
    t30 = call printf, 3
L2:
    t31 = i
    i = i + 1
    goto L0
L1:
    return
add:
     = a param_decl int
     = b param_decl int
    t32 = a + b
    return t32
testcase4:
    fp = add
    param "\nTESTCASE 4: Pointer to Function\n"
    t33 = call printf, 1
    param "add(5,7) using fp = %d\n"
    param 5
    param 7
    t34 = call* fp, 2
    param t34
    t35 = call printf, 2
    return
getDanglingPtr:
    x[0] = 50
    t36 = &x
    return t36
testcase7:
    param "\nTESTCASE 7: Dangling Pointer (unsafe)\n"
    t37 = call printf, 1
    t38 = call getDanglingPtr, 0
    dp = t38
    param "Dangling pointer value (undefined) = %d\n"
    t39 = *dp
    param t39
    t40 = call printf, 2
    return
testcase8:
    param "\nTESTCASE 8: Double Free (dangerous)\n"
    t41 = call printf, 1
    param 4
    t42 = call* malloc, 1
    ptr = t42
    *ptr = 999
    param "Value = %d\n"
    t43 = *ptr
    param t43
    t44 = call printf, 2
    param ptr
    t45 = call* free, 1
    param "Freed once\n"
    t46 = call printf, 1
    param "Double free avoided (commented out)\n"
    t47 = call printf, 1
    return
swap:
     = x param_decl int*
     = y param_decl int*
    t48 = *x
    temp = t48
    t49 = *y
    *x = t49
    *y = temp
    return
testcase9:
    a[0] = 5
    b[0] = 10
    param "\nTESTCASE 9: Swap using pointers\n"
    t50 = call printf, 1
    param "Before: a=%d b=%d\n"
    t51 = a[0]
    param t51
    t52 = b[0]
    param t52
    t53 = call printf, 3
    t54 = &a
    param t54
    t55 = &b
    param t55
    call swap, 2
    param "After : a=%d b=%d\n"
    t56 = a[0]
    param t56
    t57 = b[0]
    param t57
    t58 = call printf, 3
    return
main:
    call testcase1, 0
    call testcase2, 0
    call testcase3, 0
    call testcase4, 0
    call testcase7, 0
    call testcase8, 0
    call testcase9, 0
    return 0

Total instructions: 161

=== ABSTRACT SYNTAX TREE ===
TranslationUnit :  (line 1)
  Preprocessor : #include <stdio.h> (line 1)
  Preprocessor : #include <stdlib.h> (line 2)
  Preprocessor : #include <string.h> (line 3)
  FunctionDefinition :  (line 17)
    DeclarationSpecifiers :  (line 8)
      TypeSpecifier : void (line 8)
    FunctionDeclarator :  (line 8)
      DirectDeclarator : testcase1 (line 8)
    CompoundStatement :  (line 17)
      BlockItemList :  (line 9)
        BlockItem :  (line 9)
          Declaration :  (line 9)
            DeclarationSpecifiers :  (line 9)
              TypeSpecifier : int (line 9)
            InitDeclaratorList :  (line 9)
              InitDeclarator :  (line 9)
                ArrayDeclarator :  (line 9)
                  DirectDeclarator : arr (line 9)
                InitializerList :  (line 9)
                  InitializerList :  (line 9)
                    Initializer :  (line 9)
                      Constant : 10 (line 9)
                    Initializer :  (line 9)
                      Constant : 20 (line 9)
                    Initializer :  (line 9)
                      Constant : 30 (line 9)
                    Initializer :  (line 9)
                      Constant : 40 (line 9)
                    Initializer :  (line 9)
                      Constant : 50 (line 9)
        BlockItem :  (line 10)
          Declaration :  (line 10)
            DeclarationSpecifiers :  (line 10)
              TypeSpecifier : int (line 10)
            InitDeclaratorList :  (line 10)
              InitDeclarator :  (line 10)
                Declarator :  (line 10)
                  Pointer :  (line 10)
                  DirectDeclarator : p (line 10)
                Initializer :  (line 10)
                  Identifier : arr (line 10)
        BlockItem :  (line 12)
          ExpressionStatement :  (line 12)
            FunctionCall :  (line 12)
              Identifier : printf (line 12)
              ArgumentList :  (line 12)
                StringLiteral : "\nTESTCASE 1: Pointer Arithmetic\n" (line 12)
        BlockItem :  (line 13)
          ExpressionStatement :  (line 13)
            FunctionCall :  (line 13)
              Identifier : printf (line 13)
              ArgumentList :  (line 13)
                StringLiteral : "*(p+2) = %d\n" (line 13)
                UnaryExpression : * (line 13)
                  AdditiveExpression : + (line 13)
                    Identifier : p (line 13)
                    Constant : 2 (line 13)
        BlockItem :  (line 15)
          ExpressionStatement :  (line 15)
            PostfixExpression : ++ (line 15)
              Identifier : p (line 15)
        BlockItem :  (line 16)
          ExpressionStatement :  (line 16)
            FunctionCall :  (line 16)
              Identifier : printf (line 16)
              ArgumentList :  (line 16)
                StringLiteral : "*p after p++ = %d\n" (line 16)
                UnaryExpression : * (line 16)
                  Identifier : p (line 16)
  FunctionDefinition :  (line 31)
    DeclarationSpecifiers :  (line 22)
      TypeSpecifier : void (line 22)
    FunctionDeclarator :  (line 22)
      DirectDeclarator : testcase2 (line 22)
    CompoundStatement :  (line 31)
      BlockItemList :  (line 23)
        BlockItem :  (line 23)
          Declaration :  (line 23)
            DeclarationSpecifiers :  (line 23)
              TypeSpecifier : int (line 23)
            InitDeclaratorList :  (line 23)
              InitDeclarator :  (line 23)
                DirectDeclarator : a (line 23)
                Initializer :  (line 23)
                  Constant : 100 (line 23)
        BlockItem :  (line 24)
          Declaration :  (line 24)
            DeclarationSpecifiers :  (line 24)
              TypeSpecifier : int (line 24)
            InitDeclaratorList :  (line 24)
              InitDeclarator :  (line 24)
                Declarator :  (line 24)
                  Pointer :  (line 24)
                  DirectDeclarator : p (line 24)
                Initializer :  (line 24)
                  UnaryExpression : & (line 24)
                    Identifier : a (line 24)
        BlockItem :  (line 25)
          Declaration :  (line 25)
            DeclarationSpecifiers :  (line 25)
              TypeSpecifier : int (line 25)
            InitDeclaratorList :  (line 25)
              InitDeclarator :  (line 25)
                Declarator :  (line 25)
                  Pointer :  (line 25)
                    Pointer :  (line 25)
                  DirectDeclarator : pp (line 25)
                Initializer :  (line 25)
                  UnaryExpression : & (line 25)
                    Identifier : p (line 25)
        BlockItem :  (line 27)
          ExpressionStatement :  (line 27)
            FunctionCall :  (line 27)
              Identifier : printf (line 27)
              ArgumentList :  (line 27)
                StringLiteral : "\nTESTCASE 2: Pointer to Pointer\n" (line 27)
        BlockItem :  (line 28)
          ExpressionStatement :  (line 28)
            FunctionCall :  (line 28)
              Identifier : printf (line 28)
              ArgumentList :  (line 28)
                StringLiteral : "a = %d\n" (line 28)
                Identifier : a (line 28)
        BlockItem :  (line 29)
          ExpressionStatement :  (line 29)
            FunctionCall :  (line 29)
              Identifier : printf (line 29)
              ArgumentList :  (line 29)
                StringLiteral : "*p = %d\n" (line 29)
                UnaryExpression : * (line 29)
                  Identifier : p (line 29)
        BlockItem :  (line 30)
          ExpressionStatement :  (line 30)
            FunctionCall :  (line 30)
              Identifier : printf (line 30)
              ArgumentList :  (line 30)
                StringLiteral : "**pp = %d\n" (line 30)
                UnaryExpression : * (line 30)
                  UnaryExpression : * (line 30)
                    Identifier : pp (line 30)
  FunctionDefinition :  (line 43)
    DeclarationSpecifiers :  (line 36)
      TypeSpecifier : void (line 36)
    FunctionDeclarator :  (line 36)
      DirectDeclarator : testcase3 (line 36)
    CompoundStatement :  (line 43)
      BlockItemList :  (line 37)
        BlockItem :  (line 37)
          Declaration :  (line 37)
            DeclarationSpecifiers :  (line 37)
              TypeSpecifier : char (line 37)
            InitDeclaratorList :  (line 37)
              InitDeclarator :  (line 37)
                Declarator :  (line 37)
                  Pointer :  (line 37)
                  ArrayDeclarator :  (line 37)
                    DirectDeclarator : names (line 37)
                InitializerList :  (line 37)
                  InitializerList :  (line 37)
                    Initializer :  (line 37)
                      StringLiteral : "Alice" (line 37)
                    Initializer :  (line 37)
                      StringLiteral : "Bob" (line 37)
                    Initializer :  (line 37)
                      StringLiteral : "Charlie" (line 37)
        BlockItem :  (line 39)
          ExpressionStatement :  (line 39)
            FunctionCall :  (line 39)
              Identifier : printf (line 39)
              ArgumentList :  (line 39)
                StringLiteral : "\nTESTCASE 3: Array of Pointers\n" (line 39)
        BlockItem :  (line 42)
          ForStatement :  (line 42)
            ForInitStatement :  (line 40)
              Declaration :  (line 40)
                DeclarationSpecifiers :  (line 40)
                  TypeSpecifier : int (line 40)
                InitDeclaratorList :  (line 40)
                  InitDeclarator :  (line 40)
                    DirectDeclarator : i (line 40)
                    Initializer :  (line 40)
                      Constant : 0 (line 40)
            ExpressionStatement :  (line 40)
              RelationalExpression : < (line 40)
                Identifier : i (line 40)
                Constant : 3 (line 40)
            PostfixExpression : ++ (line 40)
              Identifier : i (line 40)
            CompoundStatement :  (line 42)
              BlockItemList :  (line 41)
                BlockItem :  (line 41)
                  ExpressionStatement :  (line 41)
                    FunctionCall :  (line 41)
                      Identifier : printf (line 41)
                      ArgumentList :  (line 41)
                        StringLiteral : "names[%d] = %s\n" (line 41)
                        Identifier : i (line 41)
                        ArraySubscript :  (line 41)
                          Identifier : names (line 41)
                          Identifier : i (line 41)
  FunctionDefinition :  (line 48)
    DeclarationSpecifiers :  (line 48)
      TypeSpecifier : int (line 48)
    FunctionDeclarator :  (line 48)
      DirectDeclarator : add (line 48)
      ParameterList :  (line 48)
        ParameterDeclaration :  (line 48)
          DeclarationSpecifiers :  (line 48)
            TypeSpecifier : int (line 48)
          DirectDeclarator : a (line 48)
        ParameterDeclaration :  (line 48)
          DeclarationSpecifiers :  (line 48)
            TypeSpecifier : int (line 48)
          DirectDeclarator : b (line 48)
    CompoundStatement :  (line 48)
      BlockItemList :  (line 48)
        BlockItem :  (line 48)
          ReturnStatement :  (line 48)
            AdditiveExpression : + (line 48)
              Identifier : a (line 48)
              Identifier : b (line 48)
  FunctionDefinition :  (line 55)
    DeclarationSpecifiers :  (line 50)
      TypeSpecifier : void (line 50)
    FunctionDeclarator :  (line 50)
      DirectDeclarator : testcase4 (line 50)
    CompoundStatement :  (line 55)
      BlockItemList :  (line 51)
        BlockItem :  (line 51)
          Declaration :  (line 51)
            DeclarationSpecifiers :  (line 51)
              TypeSpecifier : int (line 51)
            InitDeclaratorList :  (line 51)
              InitDeclarator :  (line 51)
                FunctionDeclarator :  (line 51)
                  Declarator :  (line 51)
                    Pointer :  (line 51)
                    DirectDeclarator : fp (line 51)
                  ParameterList :  (line 51)
                    ParameterDeclaration :  (line 51)
                      DeclarationSpecifiers :  (line 51)
                        TypeSpecifier : int (line 51)
                    ParameterDeclaration :  (line 51)
                      DeclarationSpecifiers :  (line 51)
                        TypeSpecifier : int (line 51)
                Initializer :  (line 51)
                  Identifier : add (line 51)
        BlockItem :  (line 53)
          ExpressionStatement :  (line 53)
            FunctionCall :  (line 53)
              Identifier : printf (line 53)
              ArgumentList :  (line 53)
                StringLiteral : "\nTESTCASE 4: Pointer to Function\n" (line 53)
        BlockItem :  (line 54)
          ExpressionStatement :  (line 54)
            FunctionCall :  (line 54)
              Identifier : printf (line 54)
              ArgumentList :  (line 54)
                StringLiteral : "add(5,7) using fp = %d\n" (line 54)
                FunctionCall :  (line 54)
                  Identifier : fp (line 54)
                  ArgumentList :  (line 54)
                    Constant : 5 (line 54)
                    Constant : 7 (line 54)
  FunctionDefinition :  (line 97)
    DeclarationSpecifiers :  (line 94)
      TypeSpecifier : int (line 94)
    Declarator :  (line 94)
      Pointer :  (line 94)
      FunctionDeclarator :  (line 94)
        DirectDeclarator : getDanglingPtr (line 94)
    CompoundStatement :  (line 97)
      BlockItemList :  (line 95)
        BlockItem :  (line 95)
          Declaration :  (line 95)
            DeclarationSpecifiers :  (line 95)
              TypeSpecifier : int (line 95)
            InitDeclaratorList :  (line 95)
              InitDeclarator :  (line 95)
                DirectDeclarator : x (line 95)
                Initializer :  (line 95)
                  Constant : 50 (line 95)
        BlockItem :  (line 96)
          ReturnStatement :  (line 96)
            UnaryExpression : & (line 96)
              Identifier : x (line 96)
  FunctionDefinition :  (line 103)
    DeclarationSpecifiers :  (line 99)
      TypeSpecifier : void (line 99)
    FunctionDeclarator :  (line 99)
      DirectDeclarator : testcase7 (line 99)
    CompoundStatement :  (line 103)
      BlockItemList :  (line 100)
        BlockItem :  (line 100)
          ExpressionStatement :  (line 100)
            FunctionCall :  (line 100)
              Identifier : printf (line 100)
              ArgumentList :  (line 100)
                StringLiteral : "\nTESTCASE 7: Dangling Pointer (unsafe)\n" (line 100)
        BlockItem :  (line 101)
          Declaration :  (line 101)
            DeclarationSpecifiers :  (line 101)
              TypeSpecifier : int (line 101)
            InitDeclaratorList :  (line 101)
              InitDeclarator :  (line 101)
                Declarator :  (line 101)
                  Pointer :  (line 101)
                  DirectDeclarator : dp (line 101)
                Initializer :  (line 101)
                  FunctionCall :  (line 101)
                    Identifier : getDanglingPtr (line 101)
        BlockItem :  (line 102)
          ExpressionStatement :  (line 102)
            FunctionCall :  (line 102)
              Identifier : printf (line 102)
              ArgumentList :  (line 102)
                StringLiteral : "Dangling pointer value (undefined) = %d\n" (line 102)
                UnaryExpression : * (line 102)
                  Identifier : dp (line 102)
  FunctionDefinition :  (line 120)
    DeclarationSpecifiers :  (line 108)
      TypeSpecifier : void (line 108)
    FunctionDeclarator :  (line 108)
      DirectDeclarator : testcase8 (line 108)
    CompoundStatement :  (line 120)
      BlockItemList :  (line 109)
        BlockItem :  (line 109)
          ExpressionStatement :  (line 109)
            FunctionCall :  (line 109)
              Identifier : printf (line 109)
              ArgumentList :  (line 109)
                StringLiteral : "\nTESTCASE 8: Double Free (dangerous)\n" (line 109)
        BlockItem :  (line 111)
          Declaration :  (line 111)
            DeclarationSpecifiers :  (line 111)
              TypeSpecifier : int (line 111)
            InitDeclaratorList :  (line 111)
              InitDeclarator :  (line 111)
                Declarator :  (line 111)
                  Pointer :  (line 111)
                  DirectDeclarator : ptr (line 111)
                Initializer :  (line 111)
                  FunctionCall :  (line 111)
                    Identifier : malloc (line 111)
                    ArgumentList :  (line 111)
                      Constant : 4 (line 111)
        BlockItem :  (line 112)
          ExpressionStatement :  (line 112)
            AssignmentExpression : = (line 112)
              UnaryExpression : * (line 112)
                Identifier : ptr (line 112)
              Constant : 999 (line 112)
        BlockItem :  (line 113)
          ExpressionStatement :  (line 113)
            FunctionCall :  (line 113)
              Identifier : printf (line 113)
              ArgumentList :  (line 113)
                StringLiteral : "Value = %d\n" (line 113)
                UnaryExpression : * (line 113)
                  Identifier : ptr (line 113)
        BlockItem :  (line 115)
          ExpressionStatement :  (line 115)
            FunctionCall :  (line 115)
              Identifier : free (line 115)
              ArgumentList :  (line 115)
                Identifier : ptr (line 115)
        BlockItem :  (line 116)
          ExpressionStatement :  (line 116)
            FunctionCall :  (line 116)
              Identifier : printf (line 116)
              ArgumentList :  (line 116)
                StringLiteral : "Freed once\n" (line 116)
        BlockItem :  (line 119)
          ExpressionStatement :  (line 119)
            FunctionCall :  (line 119)
              Identifier : printf (line 119)
              ArgumentList :  (line 119)
                StringLiteral : "Double free avoided (commented out)\n" (line 119)
  FunctionDefinition :  (line 129)
    DeclarationSpecifiers :  (line 125)
      TypeSpecifier : void (line 125)
    FunctionDeclarator :  (line 125)
      DirectDeclarator : swap (line 125)
      ParameterList :  (line 125)
        ParameterDeclaration :  (line 125)
          DeclarationSpecifiers :  (line 125)
            TypeSpecifier : int (line 125)
          Declarator :  (line 125)
            Pointer :  (line 125)
            DirectDeclarator : x (line 125)
        ParameterDeclaration :  (line 125)
          DeclarationSpecifiers :  (line 125)
            TypeSpecifier : int (line 125)
          Declarator :  (line 125)
            Pointer :  (line 125)
            DirectDeclarator : y (line 125)
    CompoundStatement :  (line 129)
      BlockItemList :  (line 126)
        BlockItem :  (line 126)
          Declaration :  (line 126)
            DeclarationSpecifiers :  (line 126)
              TypeSpecifier : int (line 126)
            InitDeclaratorList :  (line 126)
              InitDeclarator :  (line 126)
                DirectDeclarator : temp (line 126)
                Initializer :  (line 126)
                  UnaryExpression : * (line 126)
                    Identifier : x (line 126)
        BlockItem :  (line 127)
          ExpressionStatement :  (line 127)
            AssignmentExpression : = (line 127)
              UnaryExpression : * (line 127)
                Identifier : x (line 127)
              UnaryExpression : * (line 127)
                Identifier : y (line 127)
        BlockItem :  (line 128)
          ExpressionStatement :  (line 128)
            AssignmentExpression : = (line 128)
              UnaryExpression : * (line 128)
                Identifier : y (line 128)
              Identifier : temp (line 128)
  FunctionDefinition :  (line 138)
    DeclarationSpecifiers :  (line 131)
      TypeSpecifier : void (line 131)
    FunctionDeclarator :  (line 131)
      DirectDeclarator : testcase9 (line 131)
    CompoundStatement :  (line 138)
      BlockItemList :  (line 132)
        BlockItem :  (line 132)
          Declaration :  (line 132)
            DeclarationSpecifiers :  (line 132)
              TypeSpecifier : int (line 132)
            InitDeclaratorList :  (line 132)
              InitDeclarator :  (line 132)
                DirectDeclarator : a (line 132)
                Initializer :  (line 132)
                  Constant : 5 (line 132)
              InitDeclarator :  (line 132)
                DirectDeclarator : b (line 132)
                Initializer :  (line 132)
                  Constant : 10 (line 132)
        BlockItem :  (line 134)
          ExpressionStatement :  (line 134)
            FunctionCall :  (line 134)
              Identifier : printf (line 134)
              ArgumentList :  (line 134)
                StringLiteral : "\nTESTCASE 9: Swap using pointers\n" (line 134)
        BlockItem :  (line 135)
          ExpressionStatement :  (line 135)
            FunctionCall :  (line 135)
              Identifier : printf (line 135)
              ArgumentList :  (line 135)
                StringLiteral : "Before: a=%d b=%d\n" (line 135)
                Identifier : a (line 135)
                Identifier : b (line 135)
        BlockItem :  (line 136)
          ExpressionStatement :  (line 136)
            FunctionCall :  (line 136)
              Identifier : swap (line 136)
              ArgumentList :  (line 136)
                UnaryExpression : & (line 136)
                  Identifier : a (line 136)
                UnaryExpression : & (line 136)
                  Identifier : b (line 136)
        BlockItem :  (line 137)
          ExpressionStatement :  (line 137)
            FunctionCall :  (line 137)
              Identifier : printf (line 137)
              ArgumentList :  (line 137)
                StringLiteral : "After : a=%d b=%d\n" (line 137)
                Identifier : a (line 137)
                Identifier : b (line 137)
  FunctionDefinition :  (line 170)
    DeclarationSpecifiers :  (line 157)
      TypeSpecifier : int (line 157)
    FunctionDeclarator :  (line 157)
      DirectDeclarator : main (line 157)
    CompoundStatement :  (line 170)
      BlockItemList :  (line 158)
        BlockItem :  (line 158)
          ExpressionStatement :  (line 158)
            FunctionCall :  (line 158)
              Identifier : testcase1 (line 158)
        BlockItem :  (line 159)
          ExpressionStatement :  (line 159)
            FunctionCall :  (line 159)
              Identifier : testcase2 (line 159)
        BlockItem :  (line 160)
          ExpressionStatement :  (line 160)
            FunctionCall :  (line 160)
              Identifier : testcase3 (line 160)
        BlockItem :  (line 161)
          ExpressionStatement :  (line 161)
            FunctionCall :  (line 161)
              Identifier : testcase4 (line 161)
        BlockItem :  (line 164)
          ExpressionStatement :  (line 164)
            FunctionCall :  (line 164)
              Identifier : testcase7 (line 164)
        BlockItem :  (line 165)
          ExpressionStatement :  (line 165)
            FunctionCall :  (line 165)
              Identifier : testcase8 (line 165)
        BlockItem :  (line 166)
          ExpressionStatement :  (line 166)
            FunctionCall :  (line 166)
              Identifier : testcase9 (line 166)
        BlockItem :  (line 169)
          ReturnStatement :  (line 169)
            Constant : 0 (line 169)

AST DOT file generated: ast.dot
TAC file generated: output.tac

=== MIPS ASSEMBLY GENERATION ===

=== MIPS ASSEMBLY CODE ===
    # ==============================================
    #   MIPS Assembly Code
    #   Generated from Three-Address Code
    # ==============================================

.data
.align 2
str_19: .asciiz "After : a=%d b=%d\n"
.align 2
str_17: .asciiz "\nTESTCASE 9: Swap using pointers\n"
.align 2
str_16: .asciiz "Double free avoided (commented out)\n"
.align 2
str_15: .asciiz "Freed once\n"
.align 2
str_14: .asciiz "Value = %d\n"
.align 2
str_13: .asciiz "\nTESTCASE 8: Double Free (dangerous)\n"
.align 2
str_7: .asciiz "\nTESTCASE 3: Array of Pointers\n"
.align 2
str_1: .asciiz "*(p+2) = %d\n"
.align 2
str_2: .asciiz "*p after p++ = %d\n"
.align 2
str_0: .asciiz "\nTESTCASE 1: Pointer Arithmetic\n"
.align 2
str_11: .asciiz "\nTESTCASE 7: Dangling Pointer (unsafe)\n"
.align 2
str_10: .asciiz "add(5,7) using fp = %d\n"
.align 2
str_9: .asciiz "\nTESTCASE 4: Pointer to Function\n"
.align 2
str_4: .asciiz "a = %d\n"
.align 2
str_5: .asciiz "*p = %d\n"
.align 2
str_3: .asciiz "\nTESTCASE 2: Pointer to Pointer\n"
.align 2
str_8: .asciiz "names[%d] = %s\n"
.align 2
str_18: .asciiz "Before: a=%d b=%d\n"
.align 2
str_6: .asciiz "**pp = %d\n"
.align 2
str_12: .asciiz "Dangling pointer value (undefined) = %d\n"
.align 2
newline: .asciiz "\n"
.align 2
var_b: .space 4
.align 2
var_x: .space 4
.align 2
var_p: .space 4
.align 2
var_a: .space 4
.align 2
arr: .space 4
.align 2
names: .space 400

.text
.globl main


    # Function: testcase1
func_testcase1:
    # Function prologue
    addi $sp, $sp, -256
    sw $ra, 252($sp)
    sw $fp, 248($sp)
    addi $fp, $sp, 256
    sw $a0, 244($sp)
    sw $a1, 240($sp)
    sw $a2, 236($sp)
    sw $a3, 232($sp)
    sw $s0, 228($sp)
    sw $s1, 224($sp)
    sw $s2, 220($sp)
    sw $s3, 216($sp)
    sw $s4, 212($sp)
    sw $s5, 208($sp)
    sw $s6, 204($sp)
    sw $s7, 200($sp)
    la $t0, arr
    li $t1, 10
    sw $t1, 0($t0)
    li $t2, 4
    add $t1, $t0, $t2
    li $t2, 20
    sw $t2, 0($t1)
    li $t3, 8
    add $t2, $t0, $t3
    li $t3, 30
    sw $t3, 0($t2)
    li $t4, 12
    add $t3, $t0, $t4
    li $t4, 40
    sw $t4, 0($t3)
    li $t5, 16
    add $t4, $t0, $t5
    li $t0, 50
    sw $t0, 0($t4)
    la $t0, arr
    sw $t0, 0($sp)
    la $s0, str_0
    # Save string param str_0 to $s0
    # Call printf
    li $v0, 11
    li $a0, 10
    syscall
    li $v0, 11
    li $a0, 84
    syscall
    li $v0, 11
    li $a0, 69
    syscall
    li $v0, 11
    li $a0, 83
    syscall
    li $v0, 11
    li $a0, 84
    syscall
    li $v0, 11
    li $a0, 67
    syscall
    li $v0, 11
    li $a0, 65
    syscall
    li $v0, 11
    li $a0, 83
    syscall
    li $v0, 11
    li $a0, 69
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 49
    syscall
    li $v0, 11
    li $a0, 58
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 80
    syscall
    li $v0, 11
    li $a0, 111
    syscall
    li $v0, 11
    li $a0, 105
    syscall
    li $v0, 11
    li $a0, 110
    syscall
    li $v0, 11
    li $a0, 116
    syscall
    li $v0, 11
    li $a0, 101
    syscall
    li $v0, 11
    li $a0, 114
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 65
    syscall
    li $v0, 11
    li $a0, 114
    syscall
    li $v0, 11
    li $a0, 105
    syscall
    li $v0, 11
    li $a0, 116
    syscall
    li $v0, 11
    li $a0, 104
    syscall
    li $v0, 11
    li $a0, 109
    syscall
    li $v0, 11
    li $a0, 101
    syscall
    li $v0, 11
    li $a0, 116
    syscall
    li $v0, 11
    li $a0, 105
    syscall
    li $v0, 11
    li $a0, 99
    syscall
    li $v0, 11
    li $a0, 10
    syscall
    la $s1, str_1
    # Save string param str_1 to $s1
    li $t1, 2
    li $t2, 4
    mul $t0, $t1, $t2
    # Reloading p from stack
    lw $t2, 0($sp)
    add $t1, $t2, $t0
    lw $t0, 0($t1)
    move $s2, $t0
    # Save param t6 to $s2
    # Call printf
    li $v0, 11
    li $a0, 42
    syscall
    li $v0, 11
    li $a0, 40
    syscall
    li $v0, 11
    li $a0, 112
    syscall
    li $v0, 11
    li $a0, 43
    syscall
    li $v0, 11
    li $a0, 50
    syscall
    li $v0, 11
    li $a0, 41
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 61
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    # Print integer
    li $v0, 1
    move $a0, $s2
    syscall
    li $v0, 11
    li $a0, 10
    syscall
    la $t0, p
    # Reloading p from stack
    lw $t1, 0($sp)
    li $t2, 1
    add $t1, $t1, $t2
    sw $t1, 0($sp)
    la $s3, str_2
    # Save string param str_2 to $s3
    # Reloading p from stack
    lw $t1, 0($sp)
    lw $t2, 0($t1)
    move $s4, $t2
    # Save param t11 to $s4
    # Call printf
    li $v0, 11
    li $a0, 42
    syscall
    li $v0, 11
    li $a0, 112
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 97
    syscall
    li $v0, 11
    li $a0, 102
    syscall
    li $v0, 11
    li $a0, 116
    syscall
    li $v0, 11
    li $a0, 101
    syscall
    li $v0, 11
    li $a0, 114
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 112
    syscall
    li $v0, 11
    li $a0, 43
    syscall
    li $v0, 11
    li $a0, 43
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 61
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    # Print integer
    li $v0, 1
    move $a0, $s4
    syscall
    li $v0, 11
    li $a0, 10
    syscall
    # Function epilogue
    lw $s0, 228($sp)
    lw $s1, 224($sp)
    lw $s2, 220($sp)
    lw $s3, 216($sp)
    lw $s4, 212($sp)
    lw $s5, 208($sp)
    lw $s6, 204($sp)
    lw $s7, 200($sp)
    lw $fp, 248($sp)
    lw $ra, 252($sp)
    addi $sp, $sp, 256
    jr $ra

    # Function: testcase2
func_testcase2:
    # Function prologue
    addi $sp, $sp, -256
    sw $ra, 252($sp)
    sw $fp, 248($sp)
    addi $fp, $sp, 256
    sw $a0, 244($sp)
    sw $a1, 240($sp)
    sw $a2, 236($sp)
    sw $a3, 232($sp)
    sw $s0, 228($sp)
    sw $s1, 224($sp)
    sw $s2, 220($sp)
    sw $s3, 216($sp)
    sw $s4, 212($sp)
    sw $s5, 208($sp)
    sw $s6, 204($sp)
    sw $s7, 200($sp)
    li $t0, 0
    la $t1, var_a
    add $t2, $t1, $t0
    li $t0, 100
    sw $t0, 0($t2)
    la $t0, var_a
    li $t1, 0
    la $t2, var_p
    add $t3, $t2, $t1
    sw $t0, 0($t3)
    la $t0, var_p
    move $t1, $t0
    sw $t1, 0($sp)
    la $s5, str_3
    # Save string param str_3 to $s5
    # Call printf
    li $v0, 11
    li $a0, 10
    syscall
    li $v0, 11
    li $a0, 84
    syscall
    li $v0, 11
    li $a0, 69
    syscall
    li $v0, 11
    li $a0, 83
    syscall
    li $v0, 11
    li $a0, 84
    syscall
    li $v0, 11
    li $a0, 67
    syscall
    li $v0, 11
    li $a0, 65
    syscall
    li $v0, 11
    li $a0, 83
    syscall
    li $v0, 11
    li $a0, 69
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 50
    syscall
    li $v0, 11
    li $a0, 58
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 80
    syscall
    li $v0, 11
    li $a0, 111
    syscall
    li $v0, 11
    li $a0, 105
    syscall
    li $v0, 11
    li $a0, 110
    syscall
    li $v0, 11
    li $a0, 116
    syscall
    li $v0, 11
    li $a0, 101
    syscall
    li $v0, 11
    li $a0, 114
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 116
    syscall
    li $v0, 11
    li $a0, 111
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 80
    syscall
    li $v0, 11
    li $a0, 111
    syscall
    li $v0, 11
    li $a0, 105
    syscall
    li $v0, 11
    li $a0, 110
    syscall
    li $v0, 11
    li $a0, 116
    syscall
    li $v0, 11
    li $a0, 101
    syscall
    li $v0, 11
    li $a0, 114
    syscall
    li $v0, 11
    li $a0, 10
    syscall
    la $s6, str_4
    # Save string param str_4 to $s6
    li $t0, 0
    la $t1, var_a
    add $t2, $t1, $t0
    lw $t0, 0($t2)
    move $s7, $t0
    # Save param t16 to $s7
    # Call printf
    li $v0, 11
    li $a0, 97
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 61
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    # Print integer
    li $v0, 1
    move $a0, $s7
    syscall
    li $v0, 11
    li $a0, 10
    syscall
    la $s0, str_5
    # Save string param str_5 to $s0
    li $t0, 0
    la $t1, var_p
    add $t2, $t1, $t0
    lw $t0, 0($t2)
    lw $t1, 0($t0)
    move $s1, $t1
    # Save param t18 to $s1
    # Call printf
    li $v0, 11
    li $a0, 42
    syscall
    li $v0, 11
    li $a0, 112
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 61
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    # Print integer
    li $v0, 1
    move $a0, $s1
    syscall
    li $v0, 11
    li $a0, 10
    syscall
    la $s2, str_6
    # Save string param str_6 to $s2
    # Reloading pp from stack
    lw $t0, 0($sp)
    lw $t1, 0($t0)
    lw $t2, 0($t1)
    move $s3, $t2
    # Save param t21 to $s3
    # Call printf
    li $v0, 11
    li $a0, 42
    syscall
    li $v0, 11
    li $a0, 42
    syscall
    li $v0, 11
    li $a0, 112
    syscall
    li $v0, 11
    li $a0, 112
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 61
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    # Print integer
    li $v0, 1
    move $a0, $s3
    syscall
    li $v0, 11
    li $a0, 10
    syscall
    # Function epilogue
    lw $s0, 228($sp)
    lw $s1, 224($sp)
    lw $s2, 220($sp)
    lw $s3, 216($sp)
    lw $s4, 212($sp)
    lw $s5, 208($sp)
    lw $s6, 204($sp)
    lw $s7, 200($sp)
    lw $fp, 248($sp)
    lw $ra, 252($sp)
    addi $sp, $sp, 256
    jr $ra

    # Function: testcase3
func_testcase3:
    # Function prologue
    addi $sp, $sp, -256
    sw $ra, 252($sp)
    sw $fp, 248($sp)
    addi $fp, $sp, 256
    sw $a0, 244($sp)
    sw $a1, 240($sp)
    sw $a2, 236($sp)
    sw $a3, 232($sp)
    sw $s0, 228($sp)
    sw $s1, 224($sp)
    sw $s2, 220($sp)
    sw $s3, 216($sp)
    sw $s4, 212($sp)
    sw $s5, 208($sp)
    sw $s6, 204($sp)
    sw $s7, 200($sp)
    move $t0, $t1
    sw $t0, 0($sp)
    la $s4, str_7
    # Save string param str_7 to $s4
    # Call printf
    li $v0, 11
    li $a0, 10
    syscall
    li $v0, 11
    li $a0, 84
    syscall
    li $v0, 11
    li $a0, 69
    syscall
    li $v0, 11
    li $a0, 83
    syscall
    li $v0, 11
    li $a0, 84
    syscall
    li $v0, 11
    li $a0, 67
    syscall
    li $v0, 11
    li $a0, 65
    syscall
    li $v0, 11
    li $a0, 83
    syscall
    li $v0, 11
    li $a0, 69
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 51
    syscall
    li $v0, 11
    li $a0, 58
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 65
    syscall
    li $v0, 11
    li $a0, 114
    syscall
    li $v0, 11
    li $a0, 114
    syscall
    li $v0, 11
    li $a0, 97
    syscall
    li $v0, 11
    li $a0, 121
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 111
    syscall
    li $v0, 11
    li $a0, 102
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 80
    syscall
    li $v0, 11
    li $a0, 111
    syscall
    li $v0, 11
    li $a0, 105
    syscall
    li $v0, 11
    li $a0, 110
    syscall
    li $v0, 11
    li $a0, 116
    syscall
    li $v0, 11
    li $a0, 101
    syscall
    li $v0, 11
    li $a0, 114
    syscall
    li $v0, 11
    li $a0, 115
    syscall
    li $v0, 11
    li $a0, 10
    syscall
    li $t0, 0
    sw $t0, 4($sp)
L0:
    # Reloading i from stack
    lw $t1, 4($sp)
    li $t2, 3
    slt $t0, $t1, $t2
    beq $t0, $zero, L1
    la $s5, str_8
    # Save string param str_8 to $s5
    move $s6, $t1
    # Save param i to $s6
    li $t2, 1
    mul $t0, $t1, $t2
    move $t2, $sp
    add $t3, $t2, $t0
    lbu $t0, 0($t3)
    move $s7, $t0
    # Save param t29 to $s7
    # Call printf
    li $v0, 11
    li $a0, 110
    syscall
    li $v0, 11
    li $a0, 97
    syscall
    li $v0, 11
    li $a0, 109
    syscall
    li $v0, 11
    li $a0, 101
    syscall
    li $v0, 11
    li $a0, 115
    syscall
    li $v0, 11
    li $a0, 91
    syscall
    # Print integer
    li $v0, 1
    move $a0, $s6
    syscall
    li $v0, 11
    li $a0, 93
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 61
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    # Print string
    li $v0, 4
    move $a0, $s7
    syscall
    li $v0, 11
    li $a0, 10
    syscall
L2:
    # Reloading i from stack
    lw $t1, 4($sp)
    move $t0, $t1
    li $t2, 1
    add $t1, $t1, $t2
    sw $t1, 4($sp)
    j L0
L1:
    # Function epilogue
    lw $s0, 228($sp)
    lw $s1, 224($sp)
    lw $s2, 220($sp)
    lw $s3, 216($sp)
    lw $s4, 212($sp)
    lw $s5, 208($sp)
    lw $s6, 204($sp)
    lw $s7, 200($sp)
    lw $fp, 248($sp)
    lw $ra, 252($sp)
    addi $sp, $sp, 256
    jr $ra

    # Function: add
func_add:
    # Function prologue
    addi $sp, $sp, -256
    sw $ra, 252($sp)
    sw $fp, 248($sp)
    addi $fp, $sp, 256
    sw $a0, 244($sp)
    sw $a1, 240($sp)
    sw $a2, 236($sp)
    sw $a3, 232($sp)
    sw $s0, 228($sp)
    sw $s1, 224($sp)
    sw $s2, 220($sp)
    sw $s3, 216($sp)
    sw $s4, 212($sp)
    sw $s5, 208($sp)
    sw $s6, 204($sp)
    sw $s7, 200($sp)
    # Loading parameter a from stack
    lw $t1, 244($sp)
    # Loading parameter b from stack
    lw $t2, 240($sp)
    add $t0, $t1, $t2
    move $v0, $t0
    # Function epilogue
    lw $s0, 228($sp)
    lw $s1, 224($sp)
    lw $s2, 220($sp)
    lw $s3, 216($sp)
    lw $s4, 212($sp)
    lw $s5, 208($sp)
    lw $s6, 204($sp)
    lw $s7, 200($sp)
    lw $fp, 248($sp)
    lw $ra, 252($sp)
    addi $sp, $sp, 256
    jr $ra

    # Function: testcase4
func_testcase4:
    # Function prologue
    addi $sp, $sp, -256
    sw $ra, 252($sp)
    sw $fp, 248($sp)
    addi $fp, $sp, 256
    sw $a0, 244($sp)
    sw $a1, 240($sp)
    sw $a2, 236($sp)
    sw $a3, 232($sp)
    sw $s0, 228($sp)
    sw $s1, 224($sp)
    sw $s2, 220($sp)
    sw $s3, 216($sp)
    sw $s4, 212($sp)
    sw $s5, 208($sp)
    sw $s6, 204($sp)
    sw $s7, 200($sp)
    la $t0, func_add
    sw $t0, 0($sp)
    la $s0, str_9
    # Save string param str_9 to $s0
    # Call printf
    li $v0, 11
    li $a0, 10
    syscall
    li $v0, 11
    li $a0, 84
    syscall
    li $v0, 11
    li $a0, 69
    syscall
    li $v0, 11
    li $a0, 83
    syscall
    li $v0, 11
    li $a0, 84
    syscall
    li $v0, 11
    li $a0, 67
    syscall
    li $v0, 11
    li $a0, 65
    syscall
    li $v0, 11
    li $a0, 83
    syscall
    li $v0, 11
    li $a0, 69
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 52
    syscall
    li $v0, 11
    li $a0, 58
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 80
    syscall
    li $v0, 11
    li $a0, 111
    syscall
    li $v0, 11
    li $a0, 105
    syscall
    li $v0, 11
    li $a0, 110
    syscall
    li $v0, 11
    li $a0, 116
    syscall
    li $v0, 11
    li $a0, 101
    syscall
    li $v0, 11
    li $a0, 114
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 116
    syscall
    li $v0, 11
    li $a0, 111
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 70
    syscall
    li $v0, 11
    li $a0, 117
    syscall
    li $v0, 11
    li $a0, 110
    syscall
    li $v0, 11
    li $a0, 99
    syscall
    li $v0, 11
    li $a0, 116
    syscall
    li $v0, 11
    li $a0, 105
    syscall
    li $v0, 11
    li $a0, 111
    syscall
    li $v0, 11
    li $a0, 110
    syscall
    li $v0, 11
    li $a0, 10
    syscall
    la $s1, str_10
    # Save string param str_10 to $s1
    # Indirect call through fp
    # Reloading fp from stack
    lw $t0, 0($sp)
    li $a0, 5
    li $a1, 7
    jalr $t0
    move $s2, $v0
    move $s3, $s2
    # Save param t34 to $s3
    # Call printf
    li $v0, 11
    li $a0, 97
    syscall
    li $v0, 11
    li $a0, 100
    syscall
    li $v0, 11
    li $a0, 100
    syscall
    li $v0, 11
    li $a0, 40
    syscall
    li $v0, 11
    li $a0, 53
    syscall
    li $v0, 11
    li $a0, 44
    syscall
    li $v0, 11
    li $a0, 55
    syscall
    li $v0, 11
    li $a0, 41
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 117
    syscall
    li $v0, 11
    li $a0, 115
    syscall
    li $v0, 11
    li $a0, 105
    syscall
    li $v0, 11
    li $a0, 110
    syscall
    li $v0, 11
    li $a0, 103
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 102
    syscall
    li $v0, 11
    li $a0, 112
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 61
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    # Print integer
    li $v0, 1
    move $a0, $s3
    syscall
    li $v0, 11
    li $a0, 10
    syscall
    # Function epilogue
    lw $s0, 228($sp)
    lw $s1, 224($sp)
    lw $s2, 220($sp)
    lw $s3, 216($sp)
    lw $s4, 212($sp)
    lw $s5, 208($sp)
    lw $s6, 204($sp)
    lw $s7, 200($sp)
    lw $fp, 248($sp)
    lw $ra, 252($sp)
    addi $sp, $sp, 256
    jr $ra

    # Function: getDanglingPtr
func_getDanglingPtr:
    # Function prologue
    addi $sp, $sp, -256
    sw $ra, 252($sp)
    sw $fp, 248($sp)
    addi $fp, $sp, 256
    sw $a0, 244($sp)
    sw $a1, 240($sp)
    sw $a2, 236($sp)
    sw $a3, 232($sp)
    sw $s0, 228($sp)
    sw $s1, 224($sp)
    sw $s2, 220($sp)
    sw $s3, 216($sp)
    sw $s4, 212($sp)
    sw $s5, 208($sp)
    sw $s6, 204($sp)
    sw $s7, 200($sp)
    li $t0, 0
    la $t1, var_x
    add $t2, $t1, $t0
    li $t0, 50
    sw $t0, 0($t2)
    la $t0, var_x
    move $v0, $t0
    # Function epilogue
    lw $s0, 228($sp)
    lw $s1, 224($sp)
    lw $s2, 220($sp)
    lw $s3, 216($sp)
    lw $s4, 212($sp)
    lw $s5, 208($sp)
    lw $s6, 204($sp)
    lw $s7, 200($sp)
    lw $fp, 248($sp)
    lw $ra, 252($sp)
    addi $sp, $sp, 256
    jr $ra

    # Function: testcase7
func_testcase7:
    # Function prologue
    addi $sp, $sp, -256
    sw $ra, 252($sp)
    sw $fp, 248($sp)
    addi $fp, $sp, 256
    sw $a0, 244($sp)
    sw $a1, 240($sp)
    sw $a2, 236($sp)
    sw $a3, 232($sp)
    sw $s0, 228($sp)
    sw $s1, 224($sp)
    sw $s2, 220($sp)
    sw $s3, 216($sp)
    sw $s4, 212($sp)
    sw $s5, 208($sp)
    sw $s6, 204($sp)
    sw $s7, 200($sp)
    la $s4, str_11
    # Save string param str_11 to $s4
    # Call printf
    li $v0, 11
    li $a0, 10
    syscall
    li $v0, 11
    li $a0, 84
    syscall
    li $v0, 11
    li $a0, 69
    syscall
    li $v0, 11
    li $a0, 83
    syscall
    li $v0, 11
    li $a0, 84
    syscall
    li $v0, 11
    li $a0, 67
    syscall
    li $v0, 11
    li $a0, 65
    syscall
    li $v0, 11
    li $a0, 83
    syscall
    li $v0, 11
    li $a0, 69
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 55
    syscall
    li $v0, 11
    li $a0, 58
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 68
    syscall
    li $v0, 11
    li $a0, 97
    syscall
    li $v0, 11
    li $a0, 110
    syscall
    li $v0, 11
    li $a0, 103
    syscall
    li $v0, 11
    li $a0, 108
    syscall
    li $v0, 11
    li $a0, 105
    syscall
    li $v0, 11
    li $a0, 110
    syscall
    li $v0, 11
    li $a0, 103
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 80
    syscall
    li $v0, 11
    li $a0, 111
    syscall
    li $v0, 11
    li $a0, 105
    syscall
    li $v0, 11
    li $a0, 110
    syscall
    li $v0, 11
    li $a0, 116
    syscall
    li $v0, 11
    li $a0, 101
    syscall
    li $v0, 11
    li $a0, 114
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 40
    syscall
    li $v0, 11
    li $a0, 117
    syscall
    li $v0, 11
    li $a0, 110
    syscall
    li $v0, 11
    li $a0, 115
    syscall
    li $v0, 11
    li $a0, 97
    syscall
    li $v0, 11
    li $a0, 102
    syscall
    li $v0, 11
    li $a0, 101
    syscall
    li $v0, 11
    li $a0, 41
    syscall
    li $v0, 11
    li $a0, 10
    syscall
    # Call getDanglingPtr
    jal func_getDanglingPtr
    move $s5, $v0
    move $t0, $s5
    sw $t0, 0($sp)
    la $s6, str_12
    # Save string param str_12 to $s6
    # Reloading dp from stack
    lw $t0, 0($sp)
    lw $t1, 0($t0)
    move $s7, $t1
    # Save param t39 to $s7
    # Call printf
    li $v0, 11
    li $a0, 68
    syscall
    li $v0, 11
    li $a0, 97
    syscall
    li $v0, 11
    li $a0, 110
    syscall
    li $v0, 11
    li $a0, 103
    syscall
    li $v0, 11
    li $a0, 108
    syscall
    li $v0, 11
    li $a0, 105
    syscall
    li $v0, 11
    li $a0, 110
    syscall
    li $v0, 11
    li $a0, 103
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 112
    syscall
    li $v0, 11
    li $a0, 111
    syscall
    li $v0, 11
    li $a0, 105
    syscall
    li $v0, 11
    li $a0, 110
    syscall
    li $v0, 11
    li $a0, 116
    syscall
    li $v0, 11
    li $a0, 101
    syscall
    li $v0, 11
    li $a0, 114
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 118
    syscall
    li $v0, 11
    li $a0, 97
    syscall
    li $v0, 11
    li $a0, 108
    syscall
    li $v0, 11
    li $a0, 117
    syscall
    li $v0, 11
    li $a0, 101
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 40
    syscall
    li $v0, 11
    li $a0, 117
    syscall
    li $v0, 11
    li $a0, 110
    syscall
    li $v0, 11
    li $a0, 100
    syscall
    li $v0, 11
    li $a0, 101
    syscall
    li $v0, 11
    li $a0, 102
    syscall
    li $v0, 11
    li $a0, 105
    syscall
    li $v0, 11
    li $a0, 110
    syscall
    li $v0, 11
    li $a0, 101
    syscall
    li $v0, 11
    li $a0, 100
    syscall
    li $v0, 11
    li $a0, 41
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 61
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    # Print integer
    li $v0, 1
    move $a0, $s7
    syscall
    li $v0, 11
    li $a0, 10
    syscall
    # Function epilogue
    lw $s0, 228($sp)
    lw $s1, 224($sp)
    lw $s2, 220($sp)
    lw $s3, 216($sp)
    lw $s4, 212($sp)
    lw $s5, 208($sp)
    lw $s6, 204($sp)
    lw $s7, 200($sp)
    lw $fp, 248($sp)
    lw $ra, 252($sp)
    addi $sp, $sp, 256
    jr $ra

    # Function: testcase8
func_testcase8:
    # Function prologue
    addi $sp, $sp, -256
    sw $ra, 252($sp)
    sw $fp, 248($sp)
    addi $fp, $sp, 256
    sw $a0, 244($sp)
    sw $a1, 240($sp)
    sw $a2, 236($sp)
    sw $a3, 232($sp)
    sw $s0, 228($sp)
    sw $s1, 224($sp)
    sw $s2, 220($sp)
    sw $s3, 216($sp)
    sw $s4, 212($sp)
    sw $s5, 208($sp)
    sw $s6, 204($sp)
    sw $s7, 200($sp)
    la $s0, str_13
    # Save string param str_13 to $s0
    # Call printf
    li $v0, 11
    li $a0, 10
    syscall
    li $v0, 11
    li $a0, 84
    syscall
    li $v0, 11
    li $a0, 69
    syscall
    li $v0, 11
    li $a0, 83
    syscall
    li $v0, 11
    li $a0, 84
    syscall
    li $v0, 11
    li $a0, 67
    syscall
    li $v0, 11
    li $a0, 65
    syscall
    li $v0, 11
    li $a0, 83
    syscall
    li $v0, 11
    li $a0, 69
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 56
    syscall
    li $v0, 11
    li $a0, 58
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 68
    syscall
    li $v0, 11
    li $a0, 111
    syscall
    li $v0, 11
    li $a0, 117
    syscall
    li $v0, 11
    li $a0, 98
    syscall
    li $v0, 11
    li $a0, 108
    syscall
    li $v0, 11
    li $a0, 101
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 70
    syscall
    li $v0, 11
    li $a0, 114
    syscall
    li $v0, 11
    li $a0, 101
    syscall
    li $v0, 11
    li $a0, 101
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 40
    syscall
    li $v0, 11
    li $a0, 100
    syscall
    li $v0, 11
    li $a0, 97
    syscall
    li $v0, 11
    li $a0, 110
    syscall
    li $v0, 11
    li $a0, 103
    syscall
    li $v0, 11
    li $a0, 101
    syscall
    li $v0, 11
    li $a0, 114
    syscall
    li $v0, 11
    li $a0, 111
    syscall
    li $v0, 11
    li $a0, 117
    syscall
    li $v0, 11
    li $a0, 115
    syscall
    li $v0, 11
    li $a0, 41
    syscall
    li $v0, 11
    li $a0, 10
    syscall
    # Indirect call through malloc
    li $a0, 4
    # Spilling malloc before function call
    sw $t0, 0($sp)
    jalr $t0
    move $s1, $v0
    move $t0, $s1
    sw $t0, 4($sp)
    # Reloading ptr from stack
    lw $t0, 4($sp)
    li $t1, 999
    sw $t1, 0($t0)
    la $s2, str_14
    # Save string param str_14 to $s2
    lw $t1, 0($t0)
    move $s3, $t1
    # Save param t43 to $s3
    # Call printf
    li $v0, 11
    li $a0, 86
    syscall
    li $v0, 11
    li $a0, 97
    syscall
    li $v0, 11
    li $a0, 108
    syscall
    li $v0, 11
    li $a0, 117
    syscall
    li $v0, 11
    li $a0, 101
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 61
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    # Print integer
    li $v0, 1
    move $a0, $s3
    syscall
    li $v0, 11
    li $a0, 10
    syscall
    # Reloading ptr from stack
    lw $t0, 4($sp)
    move $s4, $t0
    # Save param ptr to $s4
    # Indirect call through free
    move $a0, $s4
    # Spilling free before function call
    sw $t1, 8($sp)
    jalr $t1
    move $s5, $v0
    la $s6, str_15
    # Save string param str_15 to $s6
    # Call printf
    li $v0, 11
    li $a0, 70
    syscall
    li $v0, 11
    li $a0, 114
    syscall
    li $v0, 11
    li $a0, 101
    syscall
    li $v0, 11
    li $a0, 101
    syscall
    li $v0, 11
    li $a0, 100
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 111
    syscall
    li $v0, 11
    li $a0, 110
    syscall
    li $v0, 11
    li $a0, 99
    syscall
    li $v0, 11
    li $a0, 101
    syscall
    li $v0, 11
    li $a0, 10
    syscall
    la $s7, str_16
    # Save string param str_16 to $s7
    # Call printf
    li $v0, 11
    li $a0, 68
    syscall
    li $v0, 11
    li $a0, 111
    syscall
    li $v0, 11
    li $a0, 117
    syscall
    li $v0, 11
    li $a0, 98
    syscall
    li $v0, 11
    li $a0, 108
    syscall
    li $v0, 11
    li $a0, 101
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 102
    syscall
    li $v0, 11
    li $a0, 114
    syscall
    li $v0, 11
    li $a0, 101
    syscall
    li $v0, 11
    li $a0, 101
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 97
    syscall
    li $v0, 11
    li $a0, 118
    syscall
    li $v0, 11
    li $a0, 111
    syscall
    li $v0, 11
    li $a0, 105
    syscall
    li $v0, 11
    li $a0, 100
    syscall
    li $v0, 11
    li $a0, 101
    syscall
    li $v0, 11
    li $a0, 100
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 40
    syscall
    li $v0, 11
    li $a0, 99
    syscall
    li $v0, 11
    li $a0, 111
    syscall
    li $v0, 11
    li $a0, 109
    syscall
    li $v0, 11
    li $a0, 109
    syscall
    li $v0, 11
    li $a0, 101
    syscall
    li $v0, 11
    li $a0, 110
    syscall
    li $v0, 11
    li $a0, 116
    syscall
    li $v0, 11
    li $a0, 101
    syscall
    li $v0, 11
    li $a0, 100
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 111
    syscall
    li $v0, 11
    li $a0, 117
    syscall
    li $v0, 11
    li $a0, 116
    syscall
    li $v0, 11
    li $a0, 41
    syscall
    li $v0, 11
    li $a0, 10
    syscall
    # Function epilogue
    lw $s0, 228($sp)
    lw $s1, 224($sp)
    lw $s2, 220($sp)
    lw $s3, 216($sp)
    lw $s4, 212($sp)
    lw $s5, 208($sp)
    lw $s6, 204($sp)
    lw $s7, 200($sp)
    lw $fp, 248($sp)
    lw $ra, 252($sp)
    addi $sp, $sp, 256
    jr $ra

    # Function: swap
func_swap:
    # Function prologue
    addi $sp, $sp, -256
    sw $ra, 252($sp)
    sw $fp, 248($sp)
    addi $fp, $sp, 256
    sw $a0, 244($sp)
    sw $a1, 240($sp)
    sw $a2, 236($sp)
    sw $a3, 232($sp)
    sw $s0, 228($sp)
    sw $s1, 224($sp)
    sw $s2, 220($sp)
    sw $s3, 216($sp)
    sw $s4, 212($sp)
    sw $s5, 208($sp)
    sw $s6, 204($sp)
    sw $s7, 200($sp)
    # Loading parameter x from stack
    lw $t0, 244($sp)
    lw $t1, 0($t0)
    move $t2, $t1
    sw $t2, 0($sp)
    # Loading parameter y from stack
    lw $t1, 240($sp)
    lw $t2, 0($t1)
    sw $t2, 0($t0)
    # Reloading temp from stack
    lw $t2, 0($sp)
    sw $t2, 0($t1)
    # Function epilogue
    lw $s0, 228($sp)
    lw $s1, 224($sp)
    lw $s2, 220($sp)
    lw $s3, 216($sp)
    lw $s4, 212($sp)
    lw $s5, 208($sp)
    lw $s6, 204($sp)
    lw $s7, 200($sp)
    lw $fp, 248($sp)
    lw $ra, 252($sp)
    addi $sp, $sp, 256
    jr $ra

    # Function: testcase9
func_testcase9:
    # Function prologue
    addi $sp, $sp, -256
    sw $ra, 252($sp)
    sw $fp, 248($sp)
    addi $fp, $sp, 256
    sw $a0, 244($sp)
    sw $a1, 240($sp)
    sw $a2, 236($sp)
    sw $a3, 232($sp)
    sw $s0, 228($sp)
    sw $s1, 224($sp)
    sw $s2, 220($sp)
    sw $s3, 216($sp)
    sw $s4, 212($sp)
    sw $s5, 208($sp)
    sw $s6, 204($sp)
    sw $s7, 200($sp)
    li $t0, 0
    la $t1, var_a
    add $t2, $t1, $t0
    li $t0, 5
    sw $t0, 0($t2)
    li $t0, 0
    la $t1, var_b
    add $t2, $t1, $t0
    li $t0, 10
    sw $t0, 0($t2)
    la $s0, str_17
    # Save string param str_17 to $s0
    # Call printf
    li $v0, 11
    li $a0, 10
    syscall
    li $v0, 11
    li $a0, 84
    syscall
    li $v0, 11
    li $a0, 69
    syscall
    li $v0, 11
    li $a0, 83
    syscall
    li $v0, 11
    li $a0, 84
    syscall
    li $v0, 11
    li $a0, 67
    syscall
    li $v0, 11
    li $a0, 65
    syscall
    li $v0, 11
    li $a0, 83
    syscall
    li $v0, 11
    li $a0, 69
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 57
    syscall
    li $v0, 11
    li $a0, 58
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 83
    syscall
    li $v0, 11
    li $a0, 119
    syscall
    li $v0, 11
    li $a0, 97
    syscall
    li $v0, 11
    li $a0, 112
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 117
    syscall
    li $v0, 11
    li $a0, 115
    syscall
    li $v0, 11
    li $a0, 105
    syscall
    li $v0, 11
    li $a0, 110
    syscall
    li $v0, 11
    li $a0, 103
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 112
    syscall
    li $v0, 11
    li $a0, 111
    syscall
    li $v0, 11
    li $a0, 105
    syscall
    li $v0, 11
    li $a0, 110
    syscall
    li $v0, 11
    li $a0, 116
    syscall
    li $v0, 11
    li $a0, 101
    syscall
    li $v0, 11
    li $a0, 114
    syscall
    li $v0, 11
    li $a0, 115
    syscall
    li $v0, 11
    li $a0, 10
    syscall
    la $s1, str_18
    # Save string param str_18 to $s1
    li $t0, 0
    la $t1, var_a
    add $t2, $t1, $t0
    lw $t0, 0($t2)
    move $s2, $t0
    # Save param t51 to $s2
    li $t0, 0
    la $t1, var_b
    add $t2, $t1, $t0
    lw $t0, 0($t2)
    move $s3, $t0
    # Save param t52 to $s3
    # Call printf
    li $v0, 11
    li $a0, 66
    syscall
    li $v0, 11
    li $a0, 101
    syscall
    li $v0, 11
    li $a0, 102
    syscall
    li $v0, 11
    li $a0, 111
    syscall
    li $v0, 11
    li $a0, 114
    syscall
    li $v0, 11
    li $a0, 101
    syscall
    li $v0, 11
    li $a0, 58
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 97
    syscall
    li $v0, 11
    li $a0, 61
    syscall
    # Print integer
    li $v0, 1
    move $a0, $s2
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 98
    syscall
    li $v0, 11
    li $a0, 61
    syscall
    # Print integer
    li $v0, 1
    move $a0, $s3
    syscall
    li $v0, 11
    li $a0, 10
    syscall
    la $t0, var_a
    move $s4, $t0
    # Save param t54 to $s4
    la $t0, var_b
    move $s5, $t0
    # Save param t55 to $s5
    # Call swap
    move $a0, $s4
    move $a1, $s5
    jal func_swap
    la $s6, str_19
    # Save string param str_19 to $s6
    li $t0, 0
    la $t1, var_a
    add $t2, $t1, $t0
    lw $t0, 0($t2)
    move $s7, $t0
    # Save param t56 to $s7
    li $t0, 0
    la $t1, var_b
    add $t2, $t1, $t0
    lw $t0, 0($t2)
    move $s0, $t0
    # Save param t57 to $s0
    # Call printf
    li $v0, 11
    li $a0, 65
    syscall
    li $v0, 11
    li $a0, 102
    syscall
    li $v0, 11
    li $a0, 116
    syscall
    li $v0, 11
    li $a0, 101
    syscall
    li $v0, 11
    li $a0, 114
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 58
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 97
    syscall
    li $v0, 11
    li $a0, 61
    syscall
    # Print integer
    li $v0, 1
    move $a0, $s7
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 98
    syscall
    li $v0, 11
    li $a0, 61
    syscall
    # Print integer
    li $v0, 1
    move $a0, $s0
    syscall
    li $v0, 11
    li $a0, 10
    syscall
    # Function epilogue
    lw $s0, 228($sp)
    lw $s1, 224($sp)
    lw $s2, 220($sp)
    lw $s3, 216($sp)
    lw $s4, 212($sp)
    lw $s5, 208($sp)
    lw $s6, 204($sp)
    lw $s7, 200($sp)
    lw $fp, 248($sp)
    lw $ra, 252($sp)
    addi $sp, $sp, 256
    jr $ra

    # Function: main
main:
    # Reserve stack space for register spills
    addi $sp, $sp, -256
    # Call testcase1
    jal func_testcase1
    # Call testcase2
    jal func_testcase2
    # Call testcase3
    jal func_testcase3
    # Call testcase4
    jal func_testcase4
    # Call testcase7
    jal func_testcase7
    # Call testcase8
    jal func_testcase8
    # Call testcase9
    jal func_testcase9
    li $v0, 0
    # Restore stack and exit program
    addi $sp, $sp, 256
    li $v0, 10
    syscall

MIPS file generated: output.s

==================================================
COMPILATION SUCCESSFUL
==================================================
