C/C++ Syntax Analyzer with AST
==============================

Token: #include <stdio.h>   Type: PREPROCESSOR   
Token: int                  Type: KEYWORD        
Token: main                 Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: )                    Type: RPAREN         
Token: {                    Type: LBRACE         
Token: int                  Type: KEYWORD        
Token: choice               Type: IDENTIFIER     
Token: =                    Type: ASSIGN         
Token: 2                    Type: INTEGER_CONSTANT
Token: ;                    Type: SEMICOLON      
Token: int                  Type: KEYWORD        
Token: value                Type: IDENTIFIER     
Token: =                    Type: ASSIGN         
Token: 10                   Type: INTEGER_CONSTANT
Token: ;                    Type: SEMICOLON      
Token: switch               Type: KEYWORD        
Token: (                    Type: LPAREN         
Token: choice               Type: IDENTIFIER     
Token: )                    Type: RPAREN         
Token: {                    Type: LBRACE         
Token: case                 Type: KEYWORD        
Token: 1                    Type: INTEGER_CONSTANT
Token: :                    Type: COLON          
Token: printf               Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: "Case 1\n"           Type: STRING_LITERAL 
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: break                Type: KEYWORD        
Token: ;                    Type: SEMICOLON      
Token: case                 Type: KEYWORD        
Token: 2                    Type: INTEGER_CONSTANT
Token: :                    Type: COLON          
Token: printf               Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: "Case 2\n"           Type: STRING_LITERAL 
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: value                Type: IDENTIFIER     
Token: =                    Type: ASSIGN         
Token: value                Type: IDENTIFIER     
Token: *                    Type: ARITHMETIC_OP  
Token: 2                    Type: INTEGER_CONSTANT
Token: ;                    Type: SEMICOLON      
Token: break                Type: KEYWORD        
Token: ;                    Type: SEMICOLON      
Token: case                 Type: KEYWORD        
Token: 3                    Type: INTEGER_CONSTANT
Token: :                    Type: COLON          
Token: case                 Type: KEYWORD        
Token: 4                    Type: INTEGER_CONSTANT
Token: :                    Type: COLON          
Token: printf               Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: "Case 3 or 4\n"      Type: STRING_LITERAL 
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: break                Type: KEYWORD        
Token: ;                    Type: SEMICOLON      
Token: default              Type: KEYWORD        
Token: :                    Type: COLON          
Token: printf               Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: "Default case\n"     Type: STRING_LITERAL 
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: }                    Type: RBRACE         
Token: printf               Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: "Value: %d\n"        Type: STRING_LITERAL 
Token: ,                    Type: COMMA          
Token: value                Type: IDENTIFIER     
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: int                  Type: KEYWORD        
Token: i                    Type: IDENTIFIER     
Token: ;                    Type: SEMICOLON      
Token: for                  Type: KEYWORD        
Token: (                    Type: LPAREN         
Token: i                    Type: IDENTIFIER     
Token: =                    Type: ASSIGN         
Token: 0                    Type: INTEGER_CONSTANT
Token: ;                    Type: SEMICOLON      
Token: i                    Type: IDENTIFIER     
Token: <                    Type: RELATIONAL_OP  
Token: 5                    Type: INTEGER_CONSTANT
Token: ;                    Type: SEMICOLON      
Token: i                    Type: IDENTIFIER     
Token: =                    Type: ASSIGN         
Token: i                    Type: IDENTIFIER     
Token: +                    Type: ARITHMETIC_OP  
Token: 1                    Type: INTEGER_CONSTANT
Token: )                    Type: RPAREN         
Token: {                    Type: LBRACE         
Token: switch               Type: KEYWORD        
Token: (                    Type: LPAREN         
Token: i                    Type: IDENTIFIER     
Token: )                    Type: RPAREN         
Token: {                    Type: LBRACE         
Token: case                 Type: KEYWORD        
Token: 0                    Type: INTEGER_CONSTANT
Token: :                    Type: COLON          
Token: printf               Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: "Zero\n"             Type: STRING_LITERAL 
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: break                Type: KEYWORD        
Token: ;                    Type: SEMICOLON      
Token: case                 Type: KEYWORD        
Token: 1                    Type: INTEGER_CONSTANT
Token: :                    Type: COLON          
Token: printf               Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: "One\n"              Type: STRING_LITERAL 
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: continue             Type: KEYWORD        
Token: ;                    Type: SEMICOLON      
Token: case                 Type: KEYWORD        
Token: 2                    Type: INTEGER_CONSTANT
Token: :                    Type: COLON          
Token: printf               Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: "Two\n"              Type: STRING_LITERAL 
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: break                Type: KEYWORD        
Token: ;                    Type: SEMICOLON      
Token: default              Type: KEYWORD        
Token: :                    Type: COLON          
Token: printf               Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: "Other: %d\n"        Type: STRING_LITERAL 
Token: ,                    Type: COMMA          
Token: i                    Type: IDENTIFIER     
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: }                    Type: RBRACE         
Token: }                    Type: RBRACE         
Token: int                  Type: KEYWORD        
Token: outer                Type: IDENTIFIER     
Token: =                    Type: ASSIGN         
Token: 1                    Type: INTEGER_CONSTANT
Token: ;                    Type: SEMICOLON      
Token: int                  Type: KEYWORD        
Token: inner                Type: IDENTIFIER     
Token: =                    Type: ASSIGN         
Token: 2                    Type: INTEGER_CONSTANT
Token: ;                    Type: SEMICOLON      
Token: switch               Type: KEYWORD        
Token: (                    Type: LPAREN         
Token: outer                Type: IDENTIFIER     
Token: )                    Type: RPAREN         
Token: {                    Type: LBRACE         
Token: case                 Type: KEYWORD        
Token: 1                    Type: INTEGER_CONSTANT
Token: :                    Type: COLON          
Token: switch               Type: KEYWORD        
Token: (                    Type: LPAREN         
Token: inner                Type: IDENTIFIER     
Token: )                    Type: RPAREN         
Token: {                    Type: LBRACE         
Token: case                 Type: KEYWORD        
Token: 1                    Type: INTEGER_CONSTANT
Token: :                    Type: COLON          
Token: printf               Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: "Inner 1\n"          Type: STRING_LITERAL 
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: break                Type: KEYWORD        
Token: ;                    Type: SEMICOLON      
Token: case                 Type: KEYWORD        
Token: 2                    Type: INTEGER_CONSTANT
Token: :                    Type: COLON          
Token: printf               Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: "Inner 2\n"          Type: STRING_LITERAL 
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: break                Type: KEYWORD        
Token: ;                    Type: SEMICOLON      
Token: }                    Type: RBRACE         
Token: break                Type: KEYWORD        
Token: ;                    Type: SEMICOLON      
Token: default              Type: KEYWORD        
Token: :                    Type: COLON          
Token: printf               Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: "Outer default\n"    Type: STRING_LITERAL 
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: }                    Type: RBRACE         
Token: return               Type: KEYWORD        
Token: 0                    Type: INTEGER_CONSTANT
Token: ;                    Type: SEMICOLON      
Token: }                    Type: RBRACE         

=== PARSING SUCCESSFUL ===

=== SEMANTIC ANALYSIS ===
=== SEMANTIC ANALYSIS STARTED ===
Line 29: WARNING: Assignment in loop condition - did you mean '=='?
=== SEMANTIC ANALYSIS COMPLETED ===
Found 0 semantic error(s)
Found 1 warning(s)

=== SYMBOL TABLE (ACTIVE SCOPES) ===
Scope 0:
  function 'main' : int (scope: 0, line: 65) [has_return]
 (scope: 0, line: 65) [has_return]
  constant 'NULL' : void* (scope: 0, line: 0)
 (scope: 0, line: 0)

 Semantic analysis passed with no errors.

=== CODE GENERATION ===

=== THREE ADDRESS CODE ===
main:
    choice = 2
    value = 10
    t0 = choice == 1
    if t0 goto L1
    t1 = choice == 2
    if t1 goto L2
    t2 = choice == 3
    if t2 goto L3
    t3 = choice == 4
    if t3 goto L3
    goto L4
L1:
    param "Case 1\n"
    t4 = call printf, 1
    goto L0
L2:
    param "Case 2\n"
    t5 = call printf, 1
    t6 = value * 2
    value = t6
    goto L0
L3:
    param "Case 3 or 4\n"
    t7 = call printf, 1
    goto L0
L4:
    param "Default case\n"
    t8 = call printf, 1
L0:
    param "Value: %d\n"
    param value
    t9 = call printf, 2
    i = 0
L5:
    t10 = i < 5
    ifFalse t10 goto L6
    t11 = i == 0
    if t11 goto L9
    t12 = i == 1
    if t12 goto L10
    t13 = i == 2
    if t13 goto L11
    goto L12
L9:
    param "Zero\n"
    t14 = call printf, 1
    goto L8
L10:
    param "One\n"
    t15 = call printf, 1
    goto L7
L11:
    param "Two\n"
    t16 = call printf, 1
    goto L8
L12:
    param "Other: %d\n"
    param i
    t17 = call printf, 2
L8:
L7:
    t18 = i + 1
    i = t18
    goto L5
L6:
    outer = 1
    inner = 2
    t19 = outer == 1
    if t19 goto L14
    goto L15
L14:
    t20 = inner == 1
    if t20 goto L17
    t21 = inner == 2
    if t21 goto L18
    goto L16
L17:
    param "Inner 1\n"
    t22 = call printf, 1
    goto L16
L18:
    param "Inner 2\n"
    t23 = call printf, 1
    goto L16
L16:
    goto L13
L15:
    param "Outer default\n"
    t24 = call printf, 1
L13:
    return 0

Total instructions: 92

=== ABSTRACT SYNTAX TREE ===
TranslationUnit :  (line 1)
  Preprocessor : #include <stdio.h> (line 1)
  FunctionDefinition :  (line 65)
    DeclarationSpecifiers :  (line 4)
      TypeSpecifier : int (line 4)
    FunctionDeclarator :  (line 4)
      DirectDeclarator : main (line 4)
    CompoundStatement :  (line 65)
      BlockItemList :  (line 5)
        BlockItem :  (line 5)
          Declaration :  (line 5)
            DeclarationSpecifiers :  (line 5)
              TypeSpecifier : int (line 5)
            InitDeclaratorList :  (line 5)
              InitDeclarator :  (line 5)
                DirectDeclarator : choice (line 5)
                Initializer :  (line 5)
                  Constant : 2 (line 5)
        BlockItem :  (line 6)
          Declaration :  (line 6)
            DeclarationSpecifiers :  (line 6)
              TypeSpecifier : int (line 6)
            InitDeclaratorList :  (line 6)
              InitDeclarator :  (line 6)
                DirectDeclarator : value (line 6)
                Initializer :  (line 6)
                  Constant : 10 (line 6)
        BlockItem :  (line 23)
          SwitchStatement :  (line 23)
            Identifier : choice (line 9)
            CompoundStatement :  (line 23)
              BlockItemList :  (line 11)
                BlockItem :  (line 11)
                  CaseStatement :  (line 11)
                    Constant : 1 (line 10)
                    ExpressionStatement :  (line 11)
                      FunctionCall :  (line 11)
                        Identifier : printf (line 11)
                        ArgumentList :  (line 11)
                          StringLiteral : "Case 1\n" (line 11)
                BlockItem :  (line 12)
                  BreakStatement :  (line 12)
                BlockItem :  (line 14)
                  CaseStatement :  (line 14)
                    Constant : 2 (line 13)
                    ExpressionStatement :  (line 14)
                      FunctionCall :  (line 14)
                        Identifier : printf (line 14)
                        ArgumentList :  (line 14)
                          StringLiteral : "Case 2\n" (line 14)
                BlockItem :  (line 15)
                  ExpressionStatement :  (line 15)
                    AssignmentExpression : = (line 15)
                      Identifier : value (line 15)
                      MultiplicativeExpression : * (line 15)
                        Identifier : value (line 15)
                        Constant : 2 (line 15)
                BlockItem :  (line 16)
                  BreakStatement :  (line 16)
                BlockItem :  (line 19)
                  CaseStatement :  (line 19)
                    Constant : 3 (line 17)
                    CaseStatement :  (line 19)
                      Constant : 4 (line 18)
                      ExpressionStatement :  (line 19)
                        FunctionCall :  (line 19)
                          Identifier : printf (line 19)
                          ArgumentList :  (line 19)
                            StringLiteral : "Case 3 or 4\n" (line 19)
                BlockItem :  (line 20)
                  BreakStatement :  (line 20)
                BlockItem :  (line 22)
                  DefaultStatement :  (line 22)
                    ExpressionStatement :  (line 22)
                      FunctionCall :  (line 22)
                        Identifier : printf (line 22)
                        ArgumentList :  (line 22)
                          StringLiteral : "Default case\n" (line 22)
        BlockItem :  (line 25)
          ExpressionStatement :  (line 25)
            FunctionCall :  (line 25)
              Identifier : printf (line 25)
              ArgumentList :  (line 25)
                StringLiteral : "Value: %d\n" (line 25)
                Identifier : value (line 25)
        BlockItem :  (line 28)
          Declaration :  (line 28)
            DeclarationSpecifiers :  (line 28)
              TypeSpecifier : int (line 28)
            InitDeclaratorList :  (line 28)
              InitDeclarator :  (line 28)
                DirectDeclarator : i (line 28)
        BlockItem :  (line 43)
          ForStatement :  (line 43)
            ForInitStatement :  (line 29)
              ExpressionStatement :  (line 29)
                AssignmentExpression : = (line 29)
                  Identifier : i (line 29)
                  Constant : 0 (line 29)
            ExpressionStatement :  (line 29)
              RelationalExpression : < (line 29)
                Identifier : i (line 29)
                Constant : 5 (line 29)
            AssignmentExpression : = (line 29)
              Identifier : i (line 29)
              AdditiveExpression : + (line 29)
                Identifier : i (line 29)
                Constant : 1 (line 29)
            CompoundStatement :  (line 43)
              BlockItemList :  (line 42)
                BlockItem :  (line 42)
                  SwitchStatement :  (line 42)
                    Identifier : i (line 30)
                    CompoundStatement :  (line 42)
                      BlockItemList :  (line 32)
                        BlockItem :  (line 32)
                          CaseStatement :  (line 32)
                            Constant : 0 (line 31)
                            ExpressionStatement :  (line 32)
                              FunctionCall :  (line 32)
                                Identifier : printf (line 32)
                                ArgumentList :  (line 32)
                                  StringLiteral : "Zero\n" (line 32)
                        BlockItem :  (line 33)
                          BreakStatement :  (line 33)
                        BlockItem :  (line 35)
                          CaseStatement :  (line 35)
                            Constant : 1 (line 34)
                            ExpressionStatement :  (line 35)
                              FunctionCall :  (line 35)
                                Identifier : printf (line 35)
                                ArgumentList :  (line 35)
                                  StringLiteral : "One\n" (line 35)
                        BlockItem :  (line 36)
                          ContinueStatement :  (line 36)
                        BlockItem :  (line 38)
                          CaseStatement :  (line 38)
                            Constant : 2 (line 37)
                            ExpressionStatement :  (line 38)
                              FunctionCall :  (line 38)
                                Identifier : printf (line 38)
                                ArgumentList :  (line 38)
                                  StringLiteral : "Two\n" (line 38)
                        BlockItem :  (line 39)
                          BreakStatement :  (line 39)
                        BlockItem :  (line 41)
                          DefaultStatement :  (line 41)
                            ExpressionStatement :  (line 41)
                              FunctionCall :  (line 41)
                                Identifier : printf (line 41)
                                ArgumentList :  (line 41)
                                  StringLiteral : "Other: %d\n" (line 41)
                                  Identifier : i (line 41)
        BlockItem :  (line 46)
          Declaration :  (line 46)
            DeclarationSpecifiers :  (line 46)
              TypeSpecifier : int (line 46)
            InitDeclaratorList :  (line 46)
              InitDeclarator :  (line 46)
                DirectDeclarator : outer (line 46)
                Initializer :  (line 46)
                  Constant : 1 (line 46)
        BlockItem :  (line 47)
          Declaration :  (line 47)
            DeclarationSpecifiers :  (line 47)
              TypeSpecifier : int (line 47)
            InitDeclaratorList :  (line 47)
              InitDeclarator :  (line 47)
                DirectDeclarator : inner (line 47)
                Initializer :  (line 47)
                  Constant : 2 (line 47)
        BlockItem :  (line 62)
          SwitchStatement :  (line 62)
            Identifier : outer (line 49)
            CompoundStatement :  (line 62)
              BlockItemList :  (line 58)
                BlockItem :  (line 58)
                  CaseStatement :  (line 58)
                    Constant : 1 (line 50)
                    SwitchStatement :  (line 58)
                      Identifier : inner (line 51)
                      CompoundStatement :  (line 58)
                        BlockItemList :  (line 53)
                          BlockItem :  (line 53)
                            CaseStatement :  (line 53)
                              Constant : 1 (line 52)
                              ExpressionStatement :  (line 53)
                                FunctionCall :  (line 53)
                                  Identifier : printf (line 53)
                                  ArgumentList :  (line 53)
                                    StringLiteral : "Inner 1\n" (line 53)
                          BlockItem :  (line 54)
                            BreakStatement :  (line 54)
                          BlockItem :  (line 56)
                            CaseStatement :  (line 56)
                              Constant : 2 (line 55)
                              ExpressionStatement :  (line 56)
                                FunctionCall :  (line 56)
                                  Identifier : printf (line 56)
                                  ArgumentList :  (line 56)
                                    StringLiteral : "Inner 2\n" (line 56)
                          BlockItem :  (line 57)
                            BreakStatement :  (line 57)
                BlockItem :  (line 59)
                  BreakStatement :  (line 59)
                BlockItem :  (line 61)
                  DefaultStatement :  (line 61)
                    ExpressionStatement :  (line 61)
                      FunctionCall :  (line 61)
                        Identifier : printf (line 61)
                        ArgumentList :  (line 61)
                          StringLiteral : "Outer default\n" (line 61)
        BlockItem :  (line 64)
          ReturnStatement :  (line 64)
            Constant : 0 (line 64)

AST DOT file generated: ast.dot
TAC file generated: output.tac

=== MIPS ASSEMBLY GENERATION ===

=== MIPS ASSEMBLY CODE ===
    # ==============================================
    #   MIPS Assembly Code
    #   Generated from Three-Address Code
    # ==============================================

.data
.align 2
str_11: .asciiz "Outer default\n"
.align 2
str_10: .asciiz "Inner 2\n"
.align 2
str_9: .asciiz "Inner 1\n"
.align 2
str_7: .asciiz "Two\n"
.align 2
str_6: .asciiz "One\n"
.align 2
str_8: .asciiz "Other: %d\n"
.align 2
str_5: .asciiz "Zero\n"
.align 2
str_3: .asciiz "Default case\n"
.align 2
str_4: .asciiz "Value: %d\n"
.align 2
str_2: .asciiz "Case 3 or 4\n"
.align 2
str_1: .asciiz "Case 2\n"
.align 2
str_0: .asciiz "Case 1\n"
.align 2
newline: .asciiz "\n"

.text
.globl main


    # Function: main
main:
    # Reserve stack space for register spills
    addi $sp, $sp, -256
    li $t0, 2
    sw $t0, 0($sp)
    li $t0, 10
    sw $t0, 4($sp)
    # Reloading choice from stack
    lw $t1, 0($sp)
    li $t2, 1
    seq $t0, $t1, $t2
    bne $t0, $zero, L1
    li $t2, 2
    seq $t0, $t1, $t2
    bne $t0, $zero, L2
    li $t2, 3
    seq $t0, $t1, $t2
    bne $t0, $zero, L3
    li $t2, 4
    seq $t0, $t1, $t2
    bne $t0, $zero, L3
    j L4
L1:
    la $s0, str_0
    # Save string param str_0 to $s0
    # Call printf
    li $v0, 11
    li $a0, 67
    syscall
    li $v0, 11
    li $a0, 97
    syscall
    li $v0, 11
    li $a0, 115
    syscall
    li $v0, 11
    li $a0, 101
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 49
    syscall
    li $v0, 11
    li $a0, 10
    syscall
    j L0
L2:
    la $s1, str_1
    # Save string param str_1 to $s1
    # Call printf
    li $v0, 11
    li $a0, 67
    syscall
    li $v0, 11
    li $a0, 97
    syscall
    li $v0, 11
    li $a0, 115
    syscall
    li $v0, 11
    li $a0, 101
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 50
    syscall
    li $v0, 11
    li $a0, 10
    syscall
    # Reloading value from stack
    lw $t1, 4($sp)
    li $t2, 2
    mul $t0, $t1, $t2
    move $t1, $t0
    sw $t1, 4($sp)
    j L0
L3:
    la $s2, str_2
    # Save string param str_2 to $s2
    # Call printf
    li $v0, 11
    li $a0, 67
    syscall
    li $v0, 11
    li $a0, 97
    syscall
    li $v0, 11
    li $a0, 115
    syscall
    li $v0, 11
    li $a0, 101
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 51
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 111
    syscall
    li $v0, 11
    li $a0, 114
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 52
    syscall
    li $v0, 11
    li $a0, 10
    syscall
    j L0
L4:
    la $s3, str_3
    # Save string param str_3 to $s3
    # Call printf
    li $v0, 11
    li $a0, 68
    syscall
    li $v0, 11
    li $a0, 101
    syscall
    li $v0, 11
    li $a0, 102
    syscall
    li $v0, 11
    li $a0, 97
    syscall
    li $v0, 11
    li $a0, 117
    syscall
    li $v0, 11
    li $a0, 108
    syscall
    li $v0, 11
    li $a0, 116
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 99
    syscall
    li $v0, 11
    li $a0, 97
    syscall
    li $v0, 11
    li $a0, 115
    syscall
    li $v0, 11
    li $a0, 101
    syscall
    li $v0, 11
    li $a0, 10
    syscall
L0:
    la $s4, str_4
    # Save string param str_4 to $s4
    # Reloading value from stack
    lw $t0, 4($sp)
    move $s5, $t0
    # Save param value to $s5
    # Call printf
    li $v0, 11
    li $a0, 86
    syscall
    li $v0, 11
    li $a0, 97
    syscall
    li $v0, 11
    li $a0, 108
    syscall
    li $v0, 11
    li $a0, 117
    syscall
    li $v0, 11
    li $a0, 101
    syscall
    li $v0, 11
    li $a0, 58
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    # Print integer
    li $v0, 1
    move $a0, $s5
    syscall
    li $v0, 11
    li $a0, 10
    syscall
    li $t0, 0
    sw $t0, 8($sp)
L5:
    # Reloading i from stack
    lw $t1, 8($sp)
    li $t2, 5
    slt $t0, $t1, $t2
    beq $t0, $zero, L6
    li $t2, 0
    seq $t0, $t1, $t2
    bne $t0, $zero, L9
    li $t2, 1
    seq $t0, $t1, $t2
    bne $t0, $zero, L10
    li $t2, 2
    seq $t0, $t1, $t2
    bne $t0, $zero, L11
    j L12
L9:
    la $s6, str_5
    # Save string param str_5 to $s6
    # Call printf
    li $v0, 11
    li $a0, 90
    syscall
    li $v0, 11
    li $a0, 101
    syscall
    li $v0, 11
    li $a0, 114
    syscall
    li $v0, 11
    li $a0, 111
    syscall
    li $v0, 11
    li $a0, 10
    syscall
    j L8
L10:
    la $s7, str_6
    # Save string param str_6 to $s7
    # Call printf
    li $v0, 11
    li $a0, 79
    syscall
    li $v0, 11
    li $a0, 110
    syscall
    li $v0, 11
    li $a0, 101
    syscall
    li $v0, 11
    li $a0, 10
    syscall
    j L7
L11:
    la $s0, str_7
    # Save string param str_7 to $s0
    # Call printf
    li $v0, 11
    li $a0, 84
    syscall
    li $v0, 11
    li $a0, 119
    syscall
    li $v0, 11
    li $a0, 111
    syscall
    li $v0, 11
    li $a0, 10
    syscall
    j L8
L12:
    la $s1, str_8
    # Save string param str_8 to $s1
    # Reloading i from stack
    lw $t0, 8($sp)
    move $s2, $t0
    # Save param i to $s2
    # Call printf
    li $v0, 11
    li $a0, 79
    syscall
    li $v0, 11
    li $a0, 116
    syscall
    li $v0, 11
    li $a0, 104
    syscall
    li $v0, 11
    li $a0, 101
    syscall
    li $v0, 11
    li $a0, 114
    syscall
    li $v0, 11
    li $a0, 58
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    # Print integer
    li $v0, 1
    move $a0, $s2
    syscall
    li $v0, 11
    li $a0, 10
    syscall
L8:
L7:
    # Reloading i from stack
    lw $t1, 8($sp)
    li $t2, 1
    add $t0, $t1, $t2
    move $t1, $t0
    sw $t1, 8($sp)
    j L5
L6:
    li $t0, 1
    sw $t0, 12($sp)
    li $t0, 2
    sw $t0, 16($sp)
    # Reloading outer from stack
    lw $t1, 12($sp)
    li $t2, 1
    seq $t0, $t1, $t2
    bne $t0, $zero, L14
    j L15
L14:
    # Reloading inner from stack
    lw $t1, 16($sp)
    li $t2, 1
    seq $t0, $t1, $t2
    bne $t0, $zero, L17
    li $t2, 2
    seq $t0, $t1, $t2
    bne $t0, $zero, L18
    j L16
L17:
    la $s3, str_9
    # Save string param str_9 to $s3
    # Call printf
    li $v0, 11
    li $a0, 73
    syscall
    li $v0, 11
    li $a0, 110
    syscall
    li $v0, 11
    li $a0, 110
    syscall
    li $v0, 11
    li $a0, 101
    syscall
    li $v0, 11
    li $a0, 114
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 49
    syscall
    li $v0, 11
    li $a0, 10
    syscall
    j L16
L18:
    la $s4, str_10
    # Save string param str_10 to $s4
    # Call printf
    li $v0, 11
    li $a0, 73
    syscall
    li $v0, 11
    li $a0, 110
    syscall
    li $v0, 11
    li $a0, 110
    syscall
    li $v0, 11
    li $a0, 101
    syscall
    li $v0, 11
    li $a0, 114
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 50
    syscall
    li $v0, 11
    li $a0, 10
    syscall
    j L16
L16:
    j L13
L15:
    la $s5, str_11
    # Save string param str_11 to $s5
    # Call printf
    li $v0, 11
    li $a0, 79
    syscall
    li $v0, 11
    li $a0, 117
    syscall
    li $v0, 11
    li $a0, 116
    syscall
    li $v0, 11
    li $a0, 101
    syscall
    li $v0, 11
    li $a0, 114
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 100
    syscall
    li $v0, 11
    li $a0, 101
    syscall
    li $v0, 11
    li $a0, 102
    syscall
    li $v0, 11
    li $a0, 97
    syscall
    li $v0, 11
    li $a0, 117
    syscall
    li $v0, 11
    li $a0, 108
    syscall
    li $v0, 11
    li $a0, 116
    syscall
    li $v0, 11
    li $a0, 10
    syscall
L13:
    li $v0, 0
    # Restore stack and exit program
    addi $sp, $sp, 256
    li $v0, 10
    syscall

MIPS file generated: output.s

==================================================
COMPILATION SUCCESSFUL
==================================================
