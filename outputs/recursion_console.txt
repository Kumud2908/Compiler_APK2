C/C++ Syntax Analyzer with AST
==============================

Token: #include <stdio.h>   Type: PREPROCESSOR   
Token: int                  Type: KEYWORD        
Token: fib                  Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: int                  Type: KEYWORD        
Token: n                    Type: IDENTIFIER     
Token: )                    Type: RPAREN         
Token: {                    Type: LBRACE         
Token: if                   Type: KEYWORD        
Token: (                    Type: LPAREN         
Token: n                    Type: IDENTIFIER     
Token: <=                   Type: RELATIONAL_OP  
Token: 1                    Type: INTEGER_CONSTANT
Token: )                    Type: RPAREN         
Token: {                    Type: LBRACE         
Token: return               Type: KEYWORD        
Token: n                    Type: IDENTIFIER     
Token: ;                    Type: SEMICOLON      
Token: }                    Type: RBRACE         
Token: return               Type: KEYWORD        
Token: fib                  Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: n                    Type: IDENTIFIER     
Token: -                    Type: ARITHMETIC_OP  
Token: 1                    Type: INTEGER_CONSTANT
Token: )                    Type: RPAREN         
Token: +                    Type: ARITHMETIC_OP  
Token: fib                  Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: n                    Type: IDENTIFIER     
Token: -                    Type: ARITHMETIC_OP  
Token: 2                    Type: INTEGER_CONSTANT
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: }                    Type: RBRACE         
Token: int                  Type: KEYWORD        
Token: factorial            Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: int                  Type: KEYWORD        
Token: n                    Type: IDENTIFIER     
Token: )                    Type: RPAREN         
Token: {                    Type: LBRACE         
Token: if                   Type: KEYWORD        
Token: (                    Type: LPAREN         
Token: n                    Type: IDENTIFIER     
Token: <=                   Type: RELATIONAL_OP  
Token: 1                    Type: INTEGER_CONSTANT
Token: )                    Type: RPAREN         
Token: {                    Type: LBRACE         
Token: return               Type: KEYWORD        
Token: 1                    Type: INTEGER_CONSTANT
Token: ;                    Type: SEMICOLON      
Token: }                    Type: RBRACE         
Token: return               Type: KEYWORD        
Token: n                    Type: IDENTIFIER     
Token: *                    Type: ARITHMETIC_OP  
Token: factorial            Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: n                    Type: IDENTIFIER     
Token: -                    Type: ARITHMETIC_OP  
Token: 1                    Type: INTEGER_CONSTANT
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: }                    Type: RBRACE         
Token: int                  Type: KEYWORD        
Token: gcd                  Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: int                  Type: KEYWORD        
Token: a                    Type: IDENTIFIER     
Token: ,                    Type: COMMA          
Token: int                  Type: KEYWORD        
Token: b                    Type: IDENTIFIER     
Token: )                    Type: RPAREN         
Token: {                    Type: LBRACE         
Token: if                   Type: KEYWORD        
Token: (                    Type: LPAREN         
Token: b                    Type: IDENTIFIER     
Token: ==                   Type: RELATIONAL_OP  
Token: 0                    Type: INTEGER_CONSTANT
Token: )                    Type: RPAREN         
Token: {                    Type: LBRACE         
Token: return               Type: KEYWORD        
Token: a                    Type: IDENTIFIER     
Token: ;                    Type: SEMICOLON      
Token: }                    Type: RBRACE         
Token: return               Type: KEYWORD        
Token: gcd                  Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: b                    Type: IDENTIFIER     
Token: ,                    Type: COMMA          
Token: a                    Type: IDENTIFIER     
Token: %                    Type: ARITHMETIC_OP  
Token: b                    Type: IDENTIFIER     
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: }                    Type: RBRACE         
Token: int                  Type: KEYWORD        
Token: main                 Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: )                    Type: RPAREN         
Token: {                    Type: LBRACE         
Token: printf               Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: "Fib(7): %d\n"       Type: STRING_LITERAL 
Token: ,                    Type: COMMA          
Token: fib                  Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: 7                    Type: INTEGER_CONSTANT
Token: )                    Type: RPAREN         
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: printf               Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: "Factorial(5): %d\n" Type: STRING_LITERAL 
Token: ,                    Type: COMMA          
Token: factorial            Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: 5                    Type: INTEGER_CONSTANT
Token: )                    Type: RPAREN         
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: printf               Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: "GCD(48, 18): %d\n"  Type: STRING_LITERAL 
Token: ,                    Type: COMMA          
Token: gcd                  Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: 48                   Type: INTEGER_CONSTANT
Token: ,                    Type: COMMA          
Token: 18                   Type: INTEGER_CONSTANT
Token: )                    Type: RPAREN         
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: return               Type: KEYWORD        
Token: 0                    Type: INTEGER_CONSTANT
Token: ;                    Type: SEMICOLON      
Token: }                    Type: RBRACE         

=== PARSING SUCCESSFUL ===

=== SEMANTIC ANALYSIS ===
=== SEMANTIC ANALYSIS STARTED ===
=== SEMANTIC ANALYSIS COMPLETED ===
Found 0 semantic error(s)
Found 0 warning(s)

=== SYMBOL TABLE (ACTIVE SCOPES) ===
Scope 0:
  function 'main' : int (scope: 0, line: 33) [has_return]
 (scope: 0, line: 33) [has_return]
  function 'gcd' : int(int, int) (scope: 0, line: 26) [recursive] [has_return]
    parameter 'a' : int (scope: 0, line: 0)
 (scope: 0, line: 0)
    parameter 'b' : int (scope: 0, line: 0)
 (scope: 0, line: 0)
 (int a, int b) (scope: 0, line: 26) [has_return] [recursive]
  function 'factorial' : int(int) (scope: 0, line: 18) [recursive] [has_return]
    parameter 'n' : int (scope: 0, line: 0)
 (scope: 0, line: 0)
 (int n) (scope: 0, line: 18) [has_return] [recursive]
  function 'fib' : int(int) (scope: 0, line: 10) [recursive] [has_return]
    parameter 'n' : int (scope: 0, line: 0)
 (scope: 0, line: 0)
 (int n) (scope: 0, line: 10) [has_return] [recursive]
  constant 'NULL' : void* (scope: 0, line: 0)
 (scope: 0, line: 0)

 Semantic analysis passed with no errors.

=== CODE GENERATION ===

=== THREE ADDRESS CODE ===
fib:
     = n param_decl int
    t0 = n <= 1
    ifFalse t0 goto L0
    return n
L0:
    t1 = n - 1
    param t1
    t2 = call fib, 1
    t3 = n - 2
    param t3
    t4 = call fib, 1
    t5 = t2 + t4
    return t5
factorial:
     = n param_decl int
    t6 = n <= 1
    ifFalse t6 goto L2
    return 1
L2:
    t7 = n - 1
    param t7
    t8 = call factorial, 1
    t9 = n * t8
    return t9
gcd:
     = a param_decl int
     = b param_decl int
    t10 = b == 0
    ifFalse t10 goto L4
    return a
L4:
    param b
    t11 = a % b
    param t11
    t12 = call gcd, 2
    return t12
main:
    param "Fib(7): %d\n"
    param 7
    t13 = call fib, 1
    param t13
    t14 = call printf, 2
    param "Factorial(5): %d\n"
    param 5
    t15 = call factorial, 1
    param t15
    t16 = call printf, 2
    param "GCD(48, 18): %d\n"
    param 48
    param 18
    t17 = call gcd, 2
    param t17
    t18 = call printf, 2
    return 0

Total instructions: 55

=== ABSTRACT SYNTAX TREE ===
TranslationUnit :  (line 2)
  Preprocessor : #include <stdio.h> (line 2)
  FunctionDefinition :  (line 10)
    DeclarationSpecifiers :  (line 5)
      TypeSpecifier : int (line 5)
    FunctionDeclarator :  (line 5)
      DirectDeclarator : fib (line 5)
      ParameterList :  (line 5)
        ParameterDeclaration :  (line 5)
          DeclarationSpecifiers :  (line 5)
            TypeSpecifier : int (line 5)
          DirectDeclarator : n (line 5)
    CompoundStatement :  (line 10)
      BlockItemList :  (line 9)
        BlockItem :  (line 9)
          IfStatement :  (line 9)
            RelationalExpression : <= (line 6)
              Identifier : n (line 6)
              Constant : 1 (line 6)
            CompoundStatement :  (line 8)
              BlockItemList :  (line 7)
                BlockItem :  (line 7)
                  ReturnStatement :  (line 7)
                    Identifier : n (line 7)
        BlockItem :  (line 9)
          ReturnStatement :  (line 9)
            AdditiveExpression : + (line 9)
              FunctionCall :  (line 9)
                Identifier : fib (line 9)
                ArgumentList :  (line 9)
                  AdditiveExpression : - (line 9)
                    Identifier : n (line 9)
                    Constant : 1 (line 9)
              FunctionCall :  (line 9)
                Identifier : fib (line 9)
                ArgumentList :  (line 9)
                  AdditiveExpression : - (line 9)
                    Identifier : n (line 9)
                    Constant : 2 (line 9)
  FunctionDefinition :  (line 18)
    DeclarationSpecifiers :  (line 13)
      TypeSpecifier : int (line 13)
    FunctionDeclarator :  (line 13)
      DirectDeclarator : factorial (line 13)
      ParameterList :  (line 13)
        ParameterDeclaration :  (line 13)
          DeclarationSpecifiers :  (line 13)
            TypeSpecifier : int (line 13)
          DirectDeclarator : n (line 13)
    CompoundStatement :  (line 18)
      BlockItemList :  (line 17)
        BlockItem :  (line 17)
          IfStatement :  (line 17)
            RelationalExpression : <= (line 14)
              Identifier : n (line 14)
              Constant : 1 (line 14)
            CompoundStatement :  (line 16)
              BlockItemList :  (line 15)
                BlockItem :  (line 15)
                  ReturnStatement :  (line 15)
                    Constant : 1 (line 15)
        BlockItem :  (line 17)
          ReturnStatement :  (line 17)
            MultiplicativeExpression : * (line 17)
              Identifier : n (line 17)
              FunctionCall :  (line 17)
                Identifier : factorial (line 17)
                ArgumentList :  (line 17)
                  AdditiveExpression : - (line 17)
                    Identifier : n (line 17)
                    Constant : 1 (line 17)
  FunctionDefinition :  (line 26)
    DeclarationSpecifiers :  (line 21)
      TypeSpecifier : int (line 21)
    FunctionDeclarator :  (line 21)
      DirectDeclarator : gcd (line 21)
      ParameterList :  (line 21)
        ParameterDeclaration :  (line 21)
          DeclarationSpecifiers :  (line 21)
            TypeSpecifier : int (line 21)
          DirectDeclarator : a (line 21)
        ParameterDeclaration :  (line 21)
          DeclarationSpecifiers :  (line 21)
            TypeSpecifier : int (line 21)
          DirectDeclarator : b (line 21)
    CompoundStatement :  (line 26)
      BlockItemList :  (line 25)
        BlockItem :  (line 25)
          IfStatement :  (line 25)
            EqualityExpression : == (line 22)
              Identifier : b (line 22)
              Constant : 0 (line 22)
            CompoundStatement :  (line 24)
              BlockItemList :  (line 23)
                BlockItem :  (line 23)
                  ReturnStatement :  (line 23)
                    Identifier : a (line 23)
        BlockItem :  (line 25)
          ReturnStatement :  (line 25)
            FunctionCall :  (line 25)
              Identifier : gcd (line 25)
              ArgumentList :  (line 25)
                Identifier : b (line 25)
                MultiplicativeExpression : % (line 25)
                  Identifier : a (line 25)
                  Identifier : b (line 25)
  FunctionDefinition :  (line 33)
    DeclarationSpecifiers :  (line 28)
      TypeSpecifier : int (line 28)
    FunctionDeclarator :  (line 28)
      DirectDeclarator : main (line 28)
    CompoundStatement :  (line 33)
      BlockItemList :  (line 29)
        BlockItem :  (line 29)
          ExpressionStatement :  (line 29)
            FunctionCall :  (line 29)
              Identifier : printf (line 29)
              ArgumentList :  (line 29)
                StringLiteral : "Fib(7): %d\n" (line 29)
                FunctionCall :  (line 29)
                  Identifier : fib (line 29)
                  ArgumentList :  (line 29)
                    Constant : 7 (line 29)
        BlockItem :  (line 30)
          ExpressionStatement :  (line 30)
            FunctionCall :  (line 30)
              Identifier : printf (line 30)
              ArgumentList :  (line 30)
                StringLiteral : "Factorial(5): %d\n" (line 30)
                FunctionCall :  (line 30)
                  Identifier : factorial (line 30)
                  ArgumentList :  (line 30)
                    Constant : 5 (line 30)
        BlockItem :  (line 31)
          ExpressionStatement :  (line 31)
            FunctionCall :  (line 31)
              Identifier : printf (line 31)
              ArgumentList :  (line 31)
                StringLiteral : "GCD(48, 18): %d\n" (line 31)
                FunctionCall :  (line 31)
                  Identifier : gcd (line 31)
                  ArgumentList :  (line 31)
                    Constant : 48 (line 31)
                    Constant : 18 (line 31)
        BlockItem :  (line 32)
          ReturnStatement :  (line 32)
            Constant : 0 (line 32)

AST DOT file generated: ast.dot
TAC file generated: output.tac

=== MIPS ASSEMBLY GENERATION ===

=== MIPS ASSEMBLY CODE ===
    # ==============================================
    #   MIPS Assembly Code
    #   Generated from Three-Address Code
    # ==============================================

.data
.align 2
str_2: .asciiz "GCD(48, 18): %d\n"
.align 2
str_1: .asciiz "Factorial(5): %d\n"
.align 2
str_0: .asciiz "Fib(7): %d\n"
.align 2
newline: .asciiz "\n"

.text
.globl main


    # Function: fib
func_fib:
    # Function prologue
    addi $sp, $sp, -256
    sw $ra, 252($sp)
    sw $fp, 248($sp)
    addi $fp, $sp, 256
    sw $a0, 244($sp)
    sw $a1, 240($sp)
    sw $a2, 236($sp)
    sw $a3, 232($sp)
    sw $s0, 228($sp)
    sw $s1, 224($sp)
    sw $s2, 220($sp)
    sw $s3, 216($sp)
    sw $s4, 212($sp)
    sw $s5, 208($sp)
    sw $s6, 204($sp)
    sw $s7, 200($sp)
    # Loading parameter n from stack
    lw $t1, 244($sp)
    li $t2, 1
    sle $t0, $t1, $t2
    beq $t0, $zero, L0
    move $v0, $t1
    # Function epilogue
    lw $s0, 228($sp)
    lw $s1, 224($sp)
    lw $s2, 220($sp)
    lw $s3, 216($sp)
    lw $s4, 212($sp)
    lw $s5, 208($sp)
    lw $s6, 204($sp)
    lw $s7, 200($sp)
    lw $fp, 248($sp)
    lw $ra, 252($sp)
    addi $sp, $sp, 256
    jr $ra
L0:
    # Loading parameter n from stack
    lw $t1, 244($sp)
    li $t2, 1
    sub $t0, $t1, $t2
    move $s0, $t0
    # Save param t1 to $s0
    # Call fib
    move $a0, $s0
    # Spilling n before function call
    sw $t1, 0($sp)
    jal func_fib
    move $s1, $v0
    # Loading parameter n from stack
    lw $t1, 244($sp)
    li $t2, 2
    sub $t0, $t1, $t2
    move $s2, $t0
    # Save param t3 to $s2
    # Call fib
    move $a0, $s2
    jal func_fib
    move $s3, $v0
    add $t0, $s1, $s3
    move $v0, $t0
    # Function epilogue
    lw $s0, 228($sp)
    lw $s1, 224($sp)
    lw $s2, 220($sp)
    lw $s3, 216($sp)
    lw $s4, 212($sp)
    lw $s5, 208($sp)
    lw $s6, 204($sp)
    lw $s7, 200($sp)
    lw $fp, 248($sp)
    lw $ra, 252($sp)
    addi $sp, $sp, 256
    jr $ra

    # Function: factorial
func_factorial:
    # Function prologue
    addi $sp, $sp, -256
    sw $ra, 252($sp)
    sw $fp, 248($sp)
    addi $fp, $sp, 256
    sw $a0, 244($sp)
    sw $a1, 240($sp)
    sw $a2, 236($sp)
    sw $a3, 232($sp)
    sw $s0, 228($sp)
    sw $s1, 224($sp)
    sw $s2, 220($sp)
    sw $s3, 216($sp)
    sw $s4, 212($sp)
    sw $s5, 208($sp)
    sw $s6, 204($sp)
    sw $s7, 200($sp)
    # Loading parameter n from stack
    lw $t1, 244($sp)
    li $t2, 1
    sle $t0, $t1, $t2
    beq $t0, $zero, L2
    li $v0, 1
    # Function epilogue
    lw $s0, 228($sp)
    lw $s1, 224($sp)
    lw $s2, 220($sp)
    lw $s3, 216($sp)
    lw $s4, 212($sp)
    lw $s5, 208($sp)
    lw $s6, 204($sp)
    lw $s7, 200($sp)
    lw $fp, 248($sp)
    lw $ra, 252($sp)
    addi $sp, $sp, 256
    jr $ra
L2:
    # Loading parameter n from stack
    lw $t1, 244($sp)
    li $t2, 1
    sub $t0, $t1, $t2
    move $s4, $t0
    # Save param t7 to $s4
    # Call factorial
    move $a0, $s4
    # Spilling n before function call
    sw $t1, 0($sp)
    jal func_factorial
    move $s5, $v0
    # Loading parameter n from stack
    lw $t1, 244($sp)
    mul $t0, $t1, $s5
    move $v0, $t0
    # Function epilogue
    lw $s0, 228($sp)
    lw $s1, 224($sp)
    lw $s2, 220($sp)
    lw $s3, 216($sp)
    lw $s4, 212($sp)
    lw $s5, 208($sp)
    lw $s6, 204($sp)
    lw $s7, 200($sp)
    lw $fp, 248($sp)
    lw $ra, 252($sp)
    addi $sp, $sp, 256
    jr $ra

    # Function: gcd
func_gcd:
    # Function prologue
    addi $sp, $sp, -256
    sw $ra, 252($sp)
    sw $fp, 248($sp)
    addi $fp, $sp, 256
    sw $a0, 244($sp)
    sw $a1, 240($sp)
    sw $a2, 236($sp)
    sw $a3, 232($sp)
    sw $s0, 228($sp)
    sw $s1, 224($sp)
    sw $s2, 220($sp)
    sw $s3, 216($sp)
    sw $s4, 212($sp)
    sw $s5, 208($sp)
    sw $s6, 204($sp)
    sw $s7, 200($sp)
    # Loading parameter b from stack
    lw $t1, 240($sp)
    li $t2, 0
    seq $t0, $t1, $t2
    beq $t0, $zero, L4
    # Loading parameter a from stack
    lw $t0, 244($sp)
    move $v0, $t0
    # Function epilogue
    lw $s0, 228($sp)
    lw $s1, 224($sp)
    lw $s2, 220($sp)
    lw $s3, 216($sp)
    lw $s4, 212($sp)
    lw $s5, 208($sp)
    lw $s6, 204($sp)
    lw $s7, 200($sp)
    lw $fp, 248($sp)
    lw $ra, 252($sp)
    addi $sp, $sp, 256
    jr $ra
L4:
    # Loading parameter b from stack
    lw $t0, 240($sp)
    move $s6, $t0
    # Save param b to $s6
    # Loading parameter a from stack
    lw $t2, 244($sp)
    div $t2, $t0
    mfhi $t1
    move $s7, $t1
    # Save param t11 to $s7
    # Call gcd
    move $a0, $s6
    move $a1, $s7
    # Spilling a before function call
    sw $t2, 0($sp)
    # Spilling b before function call
    sw $t0, 4($sp)
    jal func_gcd
    move $s0, $v0
    move $v0, $s0
    # Function epilogue
    lw $s0, 228($sp)
    lw $s1, 224($sp)
    lw $s2, 220($sp)
    lw $s3, 216($sp)
    lw $s4, 212($sp)
    lw $s5, 208($sp)
    lw $s6, 204($sp)
    lw $s7, 200($sp)
    lw $fp, 248($sp)
    lw $ra, 252($sp)
    addi $sp, $sp, 256
    jr $ra

    # Function: main
main:
    # Reserve stack space for register spills
    addi $sp, $sp, -256
    la $s1, str_0
    # Save string param str_0 to $s1
    # Call fib
    li $a0, 7
    jal func_fib
    move $s2, $v0
    move $s3, $s2
    # Save param t13 to $s3
    # Call printf
    li $v0, 11
    li $a0, 70
    syscall
    li $v0, 11
    li $a0, 105
    syscall
    li $v0, 11
    li $a0, 98
    syscall
    li $v0, 11
    li $a0, 40
    syscall
    li $v0, 11
    li $a0, 55
    syscall
    li $v0, 11
    li $a0, 41
    syscall
    li $v0, 11
    li $a0, 58
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    # Print integer
    li $v0, 1
    move $a0, $s3
    syscall
    li $v0, 11
    li $a0, 10
    syscall
    la $s4, str_1
    # Save string param str_1 to $s4
    # Call factorial
    li $a0, 5
    jal func_factorial
    move $s5, $v0
    move $s6, $s5
    # Save param t15 to $s6
    # Call printf
    li $v0, 11
    li $a0, 70
    syscall
    li $v0, 11
    li $a0, 97
    syscall
    li $v0, 11
    li $a0, 99
    syscall
    li $v0, 11
    li $a0, 116
    syscall
    li $v0, 11
    li $a0, 111
    syscall
    li $v0, 11
    li $a0, 114
    syscall
    li $v0, 11
    li $a0, 105
    syscall
    li $v0, 11
    li $a0, 97
    syscall
    li $v0, 11
    li $a0, 108
    syscall
    li $v0, 11
    li $a0, 40
    syscall
    li $v0, 11
    li $a0, 53
    syscall
    li $v0, 11
    li $a0, 41
    syscall
    li $v0, 11
    li $a0, 58
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    # Print integer
    li $v0, 1
    move $a0, $s6
    syscall
    li $v0, 11
    li $a0, 10
    syscall
    la $s7, str_2
    # Save string param str_2 to $s7
    # Call gcd
    li $a0, 48
    li $a1, 18
    jal func_gcd
    move $s0, $v0
    move $s1, $s0
    # Save param t17 to $s1
    # Call printf
    li $v0, 11
    li $a0, 71
    syscall
    li $v0, 11
    li $a0, 67
    syscall
    li $v0, 11
    li $a0, 68
    syscall
    li $v0, 11
    li $a0, 40
    syscall
    li $v0, 11
    li $a0, 52
    syscall
    li $v0, 11
    li $a0, 56
    syscall
    li $v0, 11
    li $a0, 44
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 49
    syscall
    li $v0, 11
    li $a0, 56
    syscall
    li $v0, 11
    li $a0, 41
    syscall
    li $v0, 11
    li $a0, 58
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    # Print integer
    li $v0, 1
    move $a0, $s1
    syscall
    li $v0, 11
    li $a0, 10
    syscall
    li $v0, 0
    # Restore stack and exit program
    addi $sp, $sp, 256
    li $v0, 10
    syscall

MIPS file generated: output.s

==================================================
COMPILATION SUCCESSFUL
==================================================
