C/C++ Syntax Analyzer with AST
==============================

Token: #include <stdio.h>   Type: PREPROCESSOR   
Token: int                  Type: KEYWORD        
Token: main                 Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: )                    Type: RPAREN         
Token: {                    Type: LBRACE         
Token: int                  Type: KEYWORD        
Token: matrix               Type: IDENTIFIER     
Token: [                    Type: LBRACKET       
Token: 3                    Type: INTEGER_CONSTANT
Token: ]                    Type: RBRACKET       
Token: [                    Type: LBRACKET       
Token: 3                    Type: INTEGER_CONSTANT
Token: ]                    Type: RBRACKET       
Token: =                    Type: ASSIGN         
Token: {                    Type: LBRACE         
Token: {                    Type: LBRACE         
Token: 1                    Type: INTEGER_CONSTANT
Token: ,                    Type: COMMA          
Token: 2                    Type: INTEGER_CONSTANT
Token: ,                    Type: COMMA          
Token: 3                    Type: INTEGER_CONSTANT
Token: }                    Type: RBRACE         
Token: ,                    Type: COMMA          
Token: {                    Type: LBRACE         
Token: 4                    Type: INTEGER_CONSTANT
Token: ,                    Type: COMMA          
Token: 5                    Type: INTEGER_CONSTANT
Token: ,                    Type: COMMA          
Token: 6                    Type: INTEGER_CONSTANT
Token: }                    Type: RBRACE         
Token: ,                    Type: COMMA          
Token: {                    Type: LBRACE         
Token: 7                    Type: INTEGER_CONSTANT
Token: ,                    Type: COMMA          
Token: 8                    Type: INTEGER_CONSTANT
Token: ,                    Type: COMMA          
Token: 9                    Type: INTEGER_CONSTANT
Token: }                    Type: RBRACE         
Token: }                    Type: RBRACE         
Token: ;                    Type: SEMICOLON      
Token: int                  Type: KEYWORD        
Token: target               Type: IDENTIFIER     
Token: =                    Type: ASSIGN         
Token: 5                    Type: INTEGER_CONSTANT
Token: ;                    Type: SEMICOLON      
Token: int                  Type: KEYWORD        
Token: found                Type: IDENTIFIER     
Token: =                    Type: ASSIGN         
Token: 0                    Type: INTEGER_CONSTANT
Token: ;                    Type: SEMICOLON      
Token: int                  Type: KEYWORD        
Token: row                  Type: IDENTIFIER     
Token: =                    Type: ASSIGN         
Token: -                    Type: ARITHMETIC_OP  
Token: 1                    Type: INTEGER_CONSTANT
Token: ,                    Type: COMMA          
Token: col                  Type: IDENTIFIER     
Token: =                    Type: ASSIGN         
Token: -                    Type: ARITHMETIC_OP  
Token: 1                    Type: INTEGER_CONSTANT
Token: ;                    Type: SEMICOLON      
Token: for                  Type: KEYWORD        
Token: (                    Type: LPAREN         
Token: int                  Type: KEYWORD        
Token: i                    Type: IDENTIFIER     
Token: =                    Type: ASSIGN         
Token: 0                    Type: INTEGER_CONSTANT
Token: ;                    Type: SEMICOLON      
Token: i                    Type: IDENTIFIER     
Token: <                    Type: RELATIONAL_OP  
Token: 3                    Type: INTEGER_CONSTANT
Token: ;                    Type: SEMICOLON      
Token: i                    Type: IDENTIFIER     
Token: ++                   Type: POSTFIX_OP     
Token: )                    Type: RPAREN         
Token: {                    Type: LBRACE         
Token: for                  Type: KEYWORD        
Token: (                    Type: LPAREN         
Token: int                  Type: KEYWORD        
Token: j                    Type: IDENTIFIER     
Token: =                    Type: ASSIGN         
Token: 0                    Type: INTEGER_CONSTANT
Token: ;                    Type: SEMICOLON      
Token: j                    Type: IDENTIFIER     
Token: <                    Type: RELATIONAL_OP  
Token: 3                    Type: INTEGER_CONSTANT
Token: ;                    Type: SEMICOLON      
Token: j                    Type: IDENTIFIER     
Token: ++                   Type: POSTFIX_OP     
Token: )                    Type: RPAREN         
Token: {                    Type: LBRACE         
Token: if                   Type: KEYWORD        
Token: (                    Type: LPAREN         
Token: matrix               Type: IDENTIFIER     
Token: [                    Type: LBRACKET       
Token: i                    Type: IDENTIFIER     
Token: ]                    Type: RBRACKET       
Token: [                    Type: LBRACKET       
Token: j                    Type: IDENTIFIER     
Token: ]                    Type: RBRACKET       
Token: ==                   Type: RELATIONAL_OP  
Token: target               Type: IDENTIFIER     
Token: )                    Type: RPAREN         
Token: {                    Type: LBRACE         
Token: row                  Type: IDENTIFIER     
Token: =                    Type: ASSIGN         
Token: i                    Type: IDENTIFIER     
Token: ;                    Type: SEMICOLON      
Token: col                  Type: IDENTIFIER     
Token: =                    Type: ASSIGN         
Token: j                    Type: IDENTIFIER     
Token: ;                    Type: SEMICOLON      
Token: found                Type: IDENTIFIER     
Token: =                    Type: ASSIGN         
Token: 1                    Type: INTEGER_CONSTANT
Token: ;                    Type: SEMICOLON      
Token: goto                 Type: KEYWORD        
Token: search_done          Type: IDENTIFIER     
Token: ;                    Type: SEMICOLON      
Token: }                    Type: RBRACE         
Token: }                    Type: RBRACE         
Token: }                    Type: RBRACE         
Token: search_done          Type: IDENTIFIER     
Token: :                    Type: COLON          
Token: if                   Type: KEYWORD        
Token: (                    Type: LPAREN         
Token: found                Type: IDENTIFIER     
Token: )                    Type: RPAREN         
Token: {                    Type: LBRACE         
Token: printf               Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: "Found %d at position (%d, %d)\n" Type: STRING_LITERAL 
Token: ,                    Type: COMMA          
Token: target               Type: IDENTIFIER     
Token: ,                    Type: COMMA          
Token: row                  Type: IDENTIFIER     
Token: ,                    Type: COMMA          
Token: col                  Type: IDENTIFIER     
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: }                    Type: RBRACE         
Token: else                 Type: KEYWORD        
Token: {                    Type: LBRACE         
Token: printf               Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: "Not found\n"        Type: STRING_LITERAL 
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: }                    Type: RBRACE         
Token: int                  Type: KEYWORD        
Token: error                Type: IDENTIFIER     
Token: =                    Type: ASSIGN         
Token: 0                    Type: INTEGER_CONSTANT
Token: ;                    Type: SEMICOLON      
Token: int                  Type: KEYWORD        
Token: x                    Type: IDENTIFIER     
Token: =                    Type: ASSIGN         
Token: 10                   Type: INTEGER_CONSTANT
Token: ;                    Type: SEMICOLON      
Token: if                   Type: KEYWORD        
Token: (                    Type: LPAREN         
Token: x                    Type: IDENTIFIER     
Token: <                    Type: RELATIONAL_OP  
Token: 0                    Type: INTEGER_CONSTANT
Token: )                    Type: RPAREN         
Token: {                    Type: LBRACE         
Token: error                Type: IDENTIFIER     
Token: =                    Type: ASSIGN         
Token: 1                    Type: INTEGER_CONSTANT
Token: ;                    Type: SEMICOLON      
Token: goto                 Type: KEYWORD        
Token: cleanup              Type: IDENTIFIER     
Token: ;                    Type: SEMICOLON      
Token: }                    Type: RBRACE         
Token: printf               Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: "Processing x = %d\n" Type: STRING_LITERAL 
Token: ,                    Type: COMMA          
Token: x                    Type: IDENTIFIER     
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: x                    Type: IDENTIFIER     
Token: =                    Type: ASSIGN         
Token: x                    Type: IDENTIFIER     
Token: *                    Type: ARITHMETIC_OP  
Token: 2                    Type: INTEGER_CONSTANT
Token: ;                    Type: SEMICOLON      
Token: cleanup              Type: IDENTIFIER     
Token: :                    Type: COLON          
Token: if                   Type: KEYWORD        
Token: (                    Type: LPAREN         
Token: error                Type: IDENTIFIER     
Token: )                    Type: RPAREN         
Token: {                    Type: LBRACE         
Token: printf               Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: "Error occurred\n"   Type: STRING_LITERAL 
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: }                    Type: RBRACE         
Token: else                 Type: KEYWORD        
Token: {                    Type: LBRACE         
Token: printf               Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: "Success: x = %d\n"  Type: STRING_LITERAL 
Token: ,                    Type: COMMA          
Token: x                    Type: IDENTIFIER     
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: }                    Type: RBRACE         
Token: return               Type: KEYWORD        
Token: 0                    Type: INTEGER_CONSTANT
Token: ;                    Type: SEMICOLON      
Token: }                    Type: RBRACE         

=== PARSING SUCCESSFUL ===

=== SEMANTIC ANALYSIS ===
=== SEMANTIC ANALYSIS STARTED ===
=== SEMANTIC ANALYSIS COMPLETED ===
Found 0 semantic error(s)
Found 0 warning(s)

=== SYMBOL TABLE (ACTIVE SCOPES) ===
Scope 0:
  function 'main' : int (scope: 0, line: 49) [has_return]
 (scope: 0, line: 49) [has_return]
  constant 'NULL' : void* (scope: 0, line: 0)
 (scope: 0, line: 0)

 Semantic analysis passed with no errors.

=== CODE GENERATION ===

=== THREE ADDRESS CODE ===
main:
    t0 = &matrix
    *t0 = 1
    t1 = t0 + 4
    *t1 = 2
    t2 = t0 + 8
    *t2 = 3
    t3 = t0 + 12
    *t3 = 4
    t4 = t0 + 16
    *t4 = 5
    t5 = t0 + 20
    *t5 = 6
    t6 = t0 + 24
    *t6 = 7
    t7 = t0 + 28
    *t7 = 8
    t8 = t0 + 32
    *t8 = 9
    target = 5
    found = 0
    t9 = -1
    row = t9
    t10 = -1
    col = t10
    i = 0
L0:
    t11 = i < 3
    ifFalse t11 goto L1
    j = 0
L3:
    t12 = j < 3
    ifFalse t12 goto L4
    t13 = i * 3
    t14 = t13 + j
    t15 = t14 * 4
    t16 = &matrix
    t17 = t16 + t15
    t18 = *t17
    t19 = t18 == target
    ifFalse t19 goto L6
    row = i
    col = j
    found = 1
    goto search_done
L6:
L5:
    t20 = j
    j = j + 1
    goto L3
L4:
L2:
    t21 = i
    i = i + 1
    goto L0
L1:
search_done:
    ifFalse found goto L8
    param "Found %d at position (%d, %d)\n"
    param target
    param row
    param col
    t22 = call printf, 4
    goto L9
L8:
    param "Not found\n"
    t23 = call printf, 1
L9:
    error = 0
    x = 10
    t24 = x < 0
    ifFalse t24 goto L10
    error = 1
    goto cleanup
L10:
    param "Processing x = %d\n"
    param x
    t25 = call printf, 2
    t26 = x * 2
    x = t26
cleanup:
    ifFalse error goto L12
    param "Error occurred\n"
    t27 = call printf, 1
    goto L13
L12:
    param "Success: x = %d\n"
    param x
    t28 = call printf, 2
L13:
    return 0

Total instructions: 91

=== ABSTRACT SYNTAX TREE ===
TranslationUnit :  (line 2)
  Preprocessor : #include <stdio.h> (line 2)
  FunctionDefinition :  (line 49)
    DeclarationSpecifiers :  (line 4)
      TypeSpecifier : int (line 4)
    FunctionDeclarator :  (line 4)
      DirectDeclarator : main (line 4)
    CompoundStatement :  (line 49)
      BlockItemList :  (line 5)
        BlockItem :  (line 5)
          Declaration :  (line 5)
            DeclarationSpecifiers :  (line 5)
              TypeSpecifier : int (line 5)
            InitDeclaratorList :  (line 5)
              InitDeclarator :  (line 5)
                ArrayDeclarator :  (line 5)
                  ArrayDeclarator :  (line 5)
                    DirectDeclarator : matrix (line 5)
                    Constant : 3 (line 5)
                  Constant : 3 (line 5)
                InitializerList :  (line 5)
                  InitializerList :  (line 5)
                    InitializerList :  (line 5)
                      InitializerList :  (line 5)
                        Initializer :  (line 5)
                          Constant : 1 (line 5)
                        Initializer :  (line 5)
                          Constant : 2 (line 5)
                        Initializer :  (line 5)
                          Constant : 3 (line 5)
                    InitializerList :  (line 5)
                      InitializerList :  (line 5)
                        Initializer :  (line 5)
                          Constant : 4 (line 5)
                        Initializer :  (line 5)
                          Constant : 5 (line 5)
                        Initializer :  (line 5)
                          Constant : 6 (line 5)
                    InitializerList :  (line 5)
                      InitializerList :  (line 5)
                        Initializer :  (line 5)
                          Constant : 7 (line 5)
                        Initializer :  (line 5)
                          Constant : 8 (line 5)
                        Initializer :  (line 5)
                          Constant : 9 (line 5)
        BlockItem :  (line 6)
          Declaration :  (line 6)
            DeclarationSpecifiers :  (line 6)
              TypeSpecifier : int (line 6)
            InitDeclaratorList :  (line 6)
              InitDeclarator :  (line 6)
                DirectDeclarator : target (line 6)
                Initializer :  (line 6)
                  Constant : 5 (line 6)
        BlockItem :  (line 7)
          Declaration :  (line 7)
            DeclarationSpecifiers :  (line 7)
              TypeSpecifier : int (line 7)
            InitDeclaratorList :  (line 7)
              InitDeclarator :  (line 7)
                DirectDeclarator : found (line 7)
                Initializer :  (line 7)
                  Constant : 0 (line 7)
        BlockItem :  (line 8)
          Declaration :  (line 8)
            DeclarationSpecifiers :  (line 8)
              TypeSpecifier : int (line 8)
            InitDeclaratorList :  (line 8)
              InitDeclarator :  (line 8)
                DirectDeclarator : row (line 8)
                Initializer :  (line 8)
                  UnaryExpression : - (line 8)
                    Constant : 1 (line 8)
              InitDeclarator :  (line 8)
                DirectDeclarator : col (line 8)
                Initializer :  (line 8)
                  UnaryExpression : - (line 8)
                    Constant : 1 (line 8)
        BlockItem :  (line 20)
          ForStatement :  (line 20)
            ForInitStatement :  (line 11)
              Declaration :  (line 11)
                DeclarationSpecifiers :  (line 11)
                  TypeSpecifier : int (line 11)
                InitDeclaratorList :  (line 11)
                  InitDeclarator :  (line 11)
                    DirectDeclarator : i (line 11)
                    Initializer :  (line 11)
                      Constant : 0 (line 11)
            ExpressionStatement :  (line 11)
              RelationalExpression : < (line 11)
                Identifier : i (line 11)
                Constant : 3 (line 11)
            PostfixExpression : ++ (line 11)
              Identifier : i (line 11)
            CompoundStatement :  (line 20)
              BlockItemList :  (line 19)
                BlockItem :  (line 19)
                  ForStatement :  (line 19)
                    ForInitStatement :  (line 12)
                      Declaration :  (line 12)
                        DeclarationSpecifiers :  (line 12)
                          TypeSpecifier : int (line 12)
                        InitDeclaratorList :  (line 12)
                          InitDeclarator :  (line 12)
                            DirectDeclarator : j (line 12)
                            Initializer :  (line 12)
                              Constant : 0 (line 12)
                    ExpressionStatement :  (line 12)
                      RelationalExpression : < (line 12)
                        Identifier : j (line 12)
                        Constant : 3 (line 12)
                    PostfixExpression : ++ (line 12)
                      Identifier : j (line 12)
                    CompoundStatement :  (line 19)
                      BlockItemList :  (line 19)
                        BlockItem :  (line 19)
                          IfStatement :  (line 19)
                            EqualityExpression : == (line 13)
                              ArraySubscript :  (line 13)
                                ArraySubscript :  (line 13)
                                  Identifier : matrix (line 13)
                                  Identifier : i (line 13)
                                Identifier : j (line 13)
                              Identifier : target (line 13)
                            CompoundStatement :  (line 18)
                              BlockItemList :  (line 14)
                                BlockItem :  (line 14)
                                  ExpressionStatement :  (line 14)
                                    AssignmentExpression : = (line 14)
                                      Identifier : row (line 14)
                                      Identifier : i (line 14)
                                BlockItem :  (line 15)
                                  ExpressionStatement :  (line 15)
                                    AssignmentExpression : = (line 15)
                                      Identifier : col (line 15)
                                      Identifier : j (line 15)
                                BlockItem :  (line 16)
                                  ExpressionStatement :  (line 16)
                                    AssignmentExpression : = (line 16)
                                      Identifier : found (line 16)
                                      Constant : 1 (line 16)
                                BlockItem :  (line 17)
                                  GotoStatement : search_done (line 17)
        BlockItem :  (line 27)
          LabeledStatement : search_done (line 27)
            IfStatement :  (line 27)
              Identifier : found (line 23)
              CompoundStatement :  (line 25)
                BlockItemList :  (line 24)
                  BlockItem :  (line 24)
                    ExpressionStatement :  (line 24)
                      FunctionCall :  (line 24)
                        Identifier : printf (line 24)
                        ArgumentList :  (line 24)
                          StringLiteral : "Found %d at position (%d, %d)\n" (line 24)
                          Identifier : target (line 24)
                          Identifier : row (line 24)
                          Identifier : col (line 24)
              CompoundStatement :  (line 27)
                BlockItemList :  (line 26)
                  BlockItem :  (line 26)
                    ExpressionStatement :  (line 26)
                      FunctionCall :  (line 26)
                        Identifier : printf (line 26)
                        ArgumentList :  (line 26)
                          StringLiteral : "Not found\n" (line 26)
        BlockItem :  (line 30)
          Declaration :  (line 30)
            DeclarationSpecifiers :  (line 30)
              TypeSpecifier : int (line 30)
            InitDeclaratorList :  (line 30)
              InitDeclarator :  (line 30)
                DirectDeclarator : error (line 30)
                Initializer :  (line 30)
                  Constant : 0 (line 30)
        BlockItem :  (line 31)
          Declaration :  (line 31)
            DeclarationSpecifiers :  (line 31)
              TypeSpecifier : int (line 31)
            InitDeclaratorList :  (line 31)
              InitDeclarator :  (line 31)
                DirectDeclarator : x (line 31)
                Initializer :  (line 31)
                  Constant : 10 (line 31)
        BlockItem :  (line 38)
          IfStatement :  (line 38)
            RelationalExpression : < (line 33)
              Identifier : x (line 33)
              Constant : 0 (line 33)
            CompoundStatement :  (line 36)
              BlockItemList :  (line 34)
                BlockItem :  (line 34)
                  ExpressionStatement :  (line 34)
                    AssignmentExpression : = (line 34)
                      Identifier : error (line 34)
                      Constant : 1 (line 34)
                BlockItem :  (line 35)
                  GotoStatement : cleanup (line 35)
        BlockItem :  (line 38)
          ExpressionStatement :  (line 38)
            FunctionCall :  (line 38)
              Identifier : printf (line 38)
              ArgumentList :  (line 38)
                StringLiteral : "Processing x = %d\n" (line 38)
                Identifier : x (line 38)
        BlockItem :  (line 39)
          ExpressionStatement :  (line 39)
            AssignmentExpression : = (line 39)
              Identifier : x (line 39)
              MultiplicativeExpression : * (line 39)
                Identifier : x (line 39)
                Constant : 2 (line 39)
        BlockItem :  (line 46)
          LabeledStatement : cleanup (line 46)
            IfStatement :  (line 46)
              Identifier : error (line 42)
              CompoundStatement :  (line 44)
                BlockItemList :  (line 43)
                  BlockItem :  (line 43)
                    ExpressionStatement :  (line 43)
                      FunctionCall :  (line 43)
                        Identifier : printf (line 43)
                        ArgumentList :  (line 43)
                          StringLiteral : "Error occurred\n" (line 43)
              CompoundStatement :  (line 46)
                BlockItemList :  (line 45)
                  BlockItem :  (line 45)
                    ExpressionStatement :  (line 45)
                      FunctionCall :  (line 45)
                        Identifier : printf (line 45)
                        ArgumentList :  (line 45)
                          StringLiteral : "Success: x = %d\n" (line 45)
                          Identifier : x (line 45)
        BlockItem :  (line 48)
          ReturnStatement :  (line 48)
            Constant : 0 (line 48)

AST DOT file generated: ast.dot
TAC file generated: output.tac

=== MIPS ASSEMBLY GENERATION ===

=== MIPS ASSEMBLY CODE ===
    # ==============================================
    #   MIPS Assembly Code
    #   Generated from Three-Address Code
    # ==============================================

.data
.align 2
str_4: .asciiz "Success: x = %d\n"
.align 2
str_2: .asciiz "Processing x = %d\n"
.align 2
str_3: .asciiz "Error occurred\n"
.align 2
str_1: .asciiz "Not found\n"
.align 2
str_0: .asciiz "Found %d at position (%d, %d)\n"
.align 2
newline: .asciiz "\n"
.align 2
matrix: .space 36

.text
.globl main


    # Function: main
main:
    # Reserve stack space for register spills
    addi $sp, $sp, -256
    la $t0, matrix
    li $t1, 1
    sw $t1, 0($t0)
    li $t2, 4
    add $t1, $t0, $t2
    li $t2, 2
    sw $t2, 0($t1)
    li $t3, 8
    add $t2, $t0, $t3
    li $t3, 3
    sw $t3, 0($t2)
    li $t4, 12
    add $t3, $t0, $t4
    li $t4, 4
    sw $t4, 0($t3)
    li $t5, 16
    add $t4, $t0, $t5
    li $t5, 5
    sw $t5, 0($t4)
    li $t6, 20
    add $t5, $t0, $t6
    li $t6, 6
    sw $t6, 0($t5)
    li $t7, 24
    add $t6, $t0, $t7
    li $t7, 7
    sw $t7, 0($t6)
    li $t8, 28
    add $t7, $t0, $t8
    li $t8, 8
    sw $t8, 0($t7)
    li $t9, 32
    add $t8, $t0, $t9
    li $t0, 9
    sw $t0, 0($t8)
    li $t0, 5
    sw $t0, 0($sp)
    li $t0, 0
    sw $t0, 4($sp)
    li $t9, 1
    sub $t0, $zero, $t9
    move $t9, $t0
    sw $t9, 8($sp)
    li $t9, 1
    sub $t0, $zero, $t9
    move $t9, $t0
    sw $t9, 12($sp)
    li $t0, 0
    sw $t0, 16($sp)
L0:
    # Reloading i from stack
    lw $t9, 16($sp)
    li $s0, 3
    slt $t0, $t9, $s0
    beq $t0, $zero, L1
    li $t0, 0
    sw $t0, 20($sp)
L3:
    # Reloading j from stack
    lw $t9, 20($sp)
    li $s0, 3
    slt $t0, $t9, $s0
    beq $t0, $zero, L4
    # Reloading i from stack
    lw $s0, 16($sp)
    li $s1, 3
    mul $t0, $s0, $s1
    add $s1, $t0, $t9
    li $s2, 4
    mul $t0, $s1, $s2
    la $s1, matrix
    add $s2, $s1, $t0
    lw $t0, 0($s2)
    # Reloading target from stack
    lw $s2, 0($sp)
    seq $s1, $t0, $s2
    beq $s1, $zero, L6
    # Reloading row from stack
    lw $t0, 8($sp)
    move $t0, $s0
    sw $t0, 8($sp)
    # Reloading col from stack
    lw $t0, 12($sp)
    move $t0, $t9
    sw $t0, 12($sp)
    # Reloading found from stack
    lw $t0, 4($sp)
    li $t0, 1
    sw $t0, 4($sp)
    j search_done
L6:
L5:
    # Reloading j from stack
    lw $t9, 20($sp)
    move $t0, $t9
    li $s0, 1
    add $t9, $t9, $s0
    sw $t9, 20($sp)
    j L3
L4:
L2:
    # Reloading i from stack
    lw $s0, 16($sp)
    move $t9, $s0
    li $s1, 1
    add $s0, $s0, $s1
    sw $s0, 16($sp)
    j L0
L1:
search_done:
    # Reloading found from stack
    lw $s0, 4($sp)
    beq $s0, $zero, L8
    la $s1, str_0
    # Save string param str_0 to $s1
    # Reloading target from stack
    lw $s1, 0($sp)
    move $s2, $s1
    # Save param target to $s2
    # Reloading row from stack
    lw $s2, 8($sp)
    move $s3, $s2
    # Save param row to $s3
    # Reloading col from stack
    lw $s3, 12($sp)
    move $s4, $s3
    # Save param col to $s4
    # Call printf
    li $v0, 11
    li $a0, 70
    syscall
    li $v0, 11
    li $a0, 111
    syscall
    li $v0, 11
    li $a0, 117
    syscall
    li $v0, 11
    li $a0, 110
    syscall
    li $v0, 11
    li $a0, 100
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    # Print integer
    li $v0, 1
    move $a0, $s2
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 97
    syscall
    li $v0, 11
    li $a0, 116
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 112
    syscall
    li $v0, 11
    li $a0, 111
    syscall
    li $v0, 11
    li $a0, 115
    syscall
    li $v0, 11
    li $a0, 105
    syscall
    li $v0, 11
    li $a0, 116
    syscall
    li $v0, 11
    li $a0, 105
    syscall
    li $v0, 11
    li $a0, 111
    syscall
    li $v0, 11
    li $a0, 110
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 40
    syscall
    # Print integer
    li $v0, 1
    move $a0, $s3
    syscall
    li $v0, 11
    li $a0, 44
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    # Print integer
    li $v0, 1
    move $a0, $s4
    syscall
    li $v0, 11
    li $a0, 41
    syscall
    li $v0, 11
    li $a0, 10
    syscall
    j L9
L8:
    la $s5, str_1
    # Save string param str_1 to $s5
    # Call printf
    li $v0, 11
    li $a0, 78
    syscall
    li $v0, 11
    li $a0, 111
    syscall
    li $v0, 11
    li $a0, 116
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 102
    syscall
    li $v0, 11
    li $a0, 111
    syscall
    li $v0, 11
    li $a0, 117
    syscall
    li $v0, 11
    li $a0, 110
    syscall
    li $v0, 11
    li $a0, 100
    syscall
    li $v0, 11
    li $a0, 10
    syscall
L9:
    li $t0, 0
    sw $t0, 24($sp)
    li $t0, 10
    sw $t0, 28($sp)
    # Reloading x from stack
    lw $t1, 28($sp)
    li $t2, 0
    slt $t0, $t1, $t2
    beq $t0, $zero, L10
    # Reloading error from stack
    lw $t0, 24($sp)
    li $t0, 1
    sw $t0, 24($sp)
    j cleanup
L10:
    la $s6, str_2
    # Save string param str_2 to $s6
    # Reloading x from stack
    lw $t0, 28($sp)
    move $s7, $t0
    # Save param x to $s7
    # Call printf
    li $v0, 11
    li $a0, 80
    syscall
    li $v0, 11
    li $a0, 114
    syscall
    li $v0, 11
    li $a0, 111
    syscall
    li $v0, 11
    li $a0, 99
    syscall
    li $v0, 11
    li $a0, 101
    syscall
    li $v0, 11
    li $a0, 115
    syscall
    li $v0, 11
    li $a0, 115
    syscall
    li $v0, 11
    li $a0, 105
    syscall
    li $v0, 11
    li $a0, 110
    syscall
    li $v0, 11
    li $a0, 103
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 120
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 61
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    # Print integer
    li $v0, 1
    move $a0, $s7
    syscall
    li $v0, 11
    li $a0, 10
    syscall
    # Reloading x from stack
    lw $t1, 28($sp)
    li $t2, 2
    mul $t0, $t1, $t2
    move $t1, $t0
    sw $t1, 28($sp)
cleanup:
    # Reloading error from stack
    lw $t0, 24($sp)
    beq $t0, $zero, L12
    la $s0, str_3
    # Save string param str_3 to $s0
    # Call printf
    li $v0, 11
    li $a0, 69
    syscall
    li $v0, 11
    li $a0, 114
    syscall
    li $v0, 11
    li $a0, 114
    syscall
    li $v0, 11
    li $a0, 111
    syscall
    li $v0, 11
    li $a0, 114
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 111
    syscall
    li $v0, 11
    li $a0, 99
    syscall
    li $v0, 11
    li $a0, 99
    syscall
    li $v0, 11
    li $a0, 117
    syscall
    li $v0, 11
    li $a0, 114
    syscall
    li $v0, 11
    li $a0, 114
    syscall
    li $v0, 11
    li $a0, 101
    syscall
    li $v0, 11
    li $a0, 100
    syscall
    li $v0, 11
    li $a0, 10
    syscall
    j L13
L12:
    la $s1, str_4
    # Save string param str_4 to $s1
    # Reloading x from stack
    lw $t0, 28($sp)
    move $s2, $t0
    # Save param x to $s2
    # Call printf
    li $v0, 11
    li $a0, 83
    syscall
    li $v0, 11
    li $a0, 117
    syscall
    li $v0, 11
    li $a0, 99
    syscall
    li $v0, 11
    li $a0, 99
    syscall
    li $v0, 11
    li $a0, 101
    syscall
    li $v0, 11
    li $a0, 115
    syscall
    li $v0, 11
    li $a0, 115
    syscall
    li $v0, 11
    li $a0, 58
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 120
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 61
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    # Print integer
    li $v0, 1
    move $a0, $s2
    syscall
    li $v0, 11
    li $a0, 10
    syscall
L13:
    li $v0, 0
    # Restore stack and exit program
    addi $sp, $sp, 256
    li $v0, 10
    syscall

MIPS file generated: output.s

==================================================
COMPILATION SUCCESSFUL
==================================================
