C/C++ Syntax Analyzer with AST
==============================

Token: #include <stdio.h>   Type: PREPROCESSOR   
Token: int                  Type: KEYWORD        
Token: main                 Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: )                    Type: RPAREN         
Token: {                    Type: LBRACE         
Token: int                  Type: KEYWORD        
Token: x                    Type: IDENTIFIER     
Token: =                    Type: ASSIGN         
Token: 0                    Type: INTEGER_CONSTANT
Token: ;                    Type: SEMICOLON      
Token: do                   Type: KEYWORD        
Token: {                    Type: LBRACE         
Token: printf               Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: "x = %d\n"           Type: STRING_LITERAL 
Token: ,                    Type: COMMA          
Token: x                    Type: IDENTIFIER     
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: x                    Type: IDENTIFIER     
Token: ++                   Type: POSTFIX_OP     
Token: ;                    Type: SEMICOLON      
Token: }                    Type: RBRACE         
Token: while                Type: KEYWORD        
Token: (                    Type: LPAREN         
Token: !                    Type: LOGICAL_OP     
Token: (                    Type: LPAREN         
Token: x                    Type: IDENTIFIER     
Token: >=                   Type: RELATIONAL_OP  
Token: 5                    Type: INTEGER_CONSTANT
Token: )                    Type: RPAREN         
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: return               Type: KEYWORD        
Token: 0                    Type: INTEGER_CONSTANT
Token: ;                    Type: SEMICOLON      
Token: }                    Type: RBRACE         

=== PARSING SUCCESSFUL ===

=== SEMANTIC ANALYSIS ===
=== SEMANTIC ANALYSIS STARTED ===
=== SEMANTIC ANALYSIS COMPLETED ===
Found 0 semantic error(s)
Found 0 warning(s)

=== SYMBOL TABLE (ACTIVE SCOPES) ===
Scope 0:
  function 'main' : int (scope: 0, line: 13) [has_return]
 (scope: 0, line: 13) [has_return]
  constant 'NULL' : void* (scope: 0, line: 0)
 (scope: 0, line: 0)

 Semantic analysis passed with no errors.

=== CODE GENERATION ===

=== THREE ADDRESS CODE ===
main:
    x = 0
L0:
    param "x = %d\n"
    param x
    t0 = call printf, 2
    t1 = x
    x = x + 1
L1:
    t3 = x >= 5
    t2 = !t3
    if t2 goto L0
L2:
    return 0

Total instructions: 14

=== ABSTRACT SYNTAX TREE ===
TranslationUnit :  (line 1)
  Preprocessor : #include <stdio.h> (line 1)
  FunctionDefinition :  (line 13)
    DeclarationSpecifiers :  (line 3)
      TypeSpecifier : int (line 3)
    FunctionDeclarator :  (line 3)
      DirectDeclarator : main (line 3)
    CompoundStatement :  (line 13)
      BlockItemList :  (line 4)
        BlockItem :  (line 4)
          Declaration :  (line 4)
            DeclarationSpecifiers :  (line 4)
              TypeSpecifier : int (line 4)
            InitDeclaratorList :  (line 4)
              InitDeclarator :  (line 4)
                DirectDeclarator : x (line 4)
                Initializer :  (line 4)
                  Constant : 0 (line 4)
        BlockItem :  (line 10)
          DoWhileStatement :  (line 10)
            CompoundStatement :  (line 10)
              BlockItemList :  (line 8)
                BlockItem :  (line 8)
                  ExpressionStatement :  (line 8)
                    FunctionCall :  (line 8)
                      Identifier : printf (line 8)
                      ArgumentList :  (line 8)
                        StringLiteral : "x = %d\n" (line 8)
                        Identifier : x (line 8)
                BlockItem :  (line 9)
                  ExpressionStatement :  (line 9)
                    PostfixExpression : ++ (line 9)
                      Identifier : x (line 9)
            UnaryExpression : ! (line 10)
              RelationalExpression : >= (line 10)
                Identifier : x (line 10)
                Constant : 5 (line 10)
        BlockItem :  (line 12)
          ReturnStatement :  (line 12)
            Constant : 0 (line 12)

AST DOT file generated: ast.dot
TAC file generated: output.tac

=== MIPS ASSEMBLY GENERATION ===

=== MIPS ASSEMBLY CODE ===
    # ==============================================
    #   MIPS Assembly Code
    #   Generated from Three-Address Code
    # ==============================================

.data
.align 2
str_0: .asciiz "x = %d\n"
.align 2
newline: .asciiz "\n"

.text
.globl main


    # Function: main
main:
    # Reserve stack space for register spills
    addi $sp, $sp, -256
    li $t0, 0
    sw $t0, 0($sp)
L0:
    la $s0, str_0
    # Save string param str_0 to $s0
    # Reloading x from stack
    lw $t0, 0($sp)
    move $s1, $t0
    # Save param x to $s1
    # Call printf
    li $v0, 11
    li $a0, 120
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    li $v0, 11
    li $a0, 61
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    # Print integer
    li $v0, 1
    move $a0, $s1
    syscall
    li $v0, 11
    li $a0, 10
    syscall
    # Reloading x from stack
    lw $t1, 0($sp)
    move $t0, $t1
    li $t2, 1
    add $t1, $t1, $t2
    sw $t1, 0($sp)
L1:
    # Reloading x from stack
    lw $t2, 0($sp)
    li $t3, 5
    sge $t1, $t2, $t3
    seq $t3, $t1, $zero
    bne $t3, $zero, L0
L2:
    li $v0, 0
    # Restore stack and exit program
    addi $sp, $sp, 256
    li $v0, 10
    syscall

MIPS file generated: output.s

==================================================
COMPILATION SUCCESSFUL
==================================================
