C/C++ Syntax Analyzer with AST
==============================

Token: #include <stdio.h>   Type: PREPROCESSOR   
Token: int                  Type: KEYWORD        
Token: main                 Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: )                    Type: RPAREN         
Token: {                    Type: LBRACE         
Token: int                  Type: KEYWORD        
Token: matrix               Type: IDENTIFIER     
Token: [                    Type: LBRACKET       
Token: 3                    Type: INTEGER_CONSTANT
Token: ]                    Type: RBRACKET       
Token: [                    Type: LBRACKET       
Token: 3                    Type: INTEGER_CONSTANT
Token: ]                    Type: RBRACKET       
Token: ;                    Type: SEMICOLON      
Token: int                  Type: KEYWORD        
Token: sum                  Type: IDENTIFIER     
Token: =                    Type: ASSIGN         
Token: 0                    Type: INTEGER_CONSTANT
Token: ;                    Type: SEMICOLON      
Token: for                  Type: KEYWORD        
Token: (                    Type: LPAREN         
Token: int                  Type: KEYWORD        
Token: i                    Type: IDENTIFIER     
Token: =                    Type: ASSIGN         
Token: 0                    Type: INTEGER_CONSTANT
Token: ;                    Type: SEMICOLON      
Token: i                    Type: IDENTIFIER     
Token: <                    Type: RELATIONAL_OP  
Token: 3                    Type: INTEGER_CONSTANT
Token: ;                    Type: SEMICOLON      
Token: i                    Type: IDENTIFIER     
Token: ++                   Type: POSTFIX_OP     
Token: )                    Type: RPAREN         
Token: {                    Type: LBRACE         
Token: for                  Type: KEYWORD        
Token: (                    Type: LPAREN         
Token: int                  Type: KEYWORD        
Token: j                    Type: IDENTIFIER     
Token: =                    Type: ASSIGN         
Token: 0                    Type: INTEGER_CONSTANT
Token: ;                    Type: SEMICOLON      
Token: j                    Type: IDENTIFIER     
Token: <                    Type: RELATIONAL_OP  
Token: 3                    Type: INTEGER_CONSTANT
Token: ;                    Type: SEMICOLON      
Token: j                    Type: IDENTIFIER     
Token: ++                   Type: POSTFIX_OP     
Token: )                    Type: RPAREN         
Token: {                    Type: LBRACE         
Token: matrix               Type: IDENTIFIER     
Token: [                    Type: LBRACKET       
Token: i                    Type: IDENTIFIER     
Token: ]                    Type: RBRACKET       
Token: [                    Type: LBRACKET       
Token: j                    Type: IDENTIFIER     
Token: ]                    Type: RBRACKET       
Token: =                    Type: ASSIGN         
Token: i                    Type: IDENTIFIER     
Token: *                    Type: ARITHMETIC_OP  
Token: 3                    Type: INTEGER_CONSTANT
Token: +                    Type: ARITHMETIC_OP  
Token: j                    Type: IDENTIFIER     
Token: +                    Type: ARITHMETIC_OP  
Token: 1                    Type: INTEGER_CONSTANT
Token: ;                    Type: SEMICOLON      
Token: }                    Type: RBRACE         
Token: }                    Type: RBRACE         
Token: for                  Type: KEYWORD        
Token: (                    Type: LPAREN         
Token: int                  Type: KEYWORD        
Token: i                    Type: IDENTIFIER     
Token: =                    Type: ASSIGN         
Token: 0                    Type: INTEGER_CONSTANT
Token: ;                    Type: SEMICOLON      
Token: i                    Type: IDENTIFIER     
Token: <                    Type: RELATIONAL_OP  
Token: 3                    Type: INTEGER_CONSTANT
Token: ;                    Type: SEMICOLON      
Token: i                    Type: IDENTIFIER     
Token: ++                   Type: POSTFIX_OP     
Token: )                    Type: RPAREN         
Token: {                    Type: LBRACE         
Token: for                  Type: KEYWORD        
Token: (                    Type: LPAREN         
Token: int                  Type: KEYWORD        
Token: j                    Type: IDENTIFIER     
Token: =                    Type: ASSIGN         
Token: 0                    Type: INTEGER_CONSTANT
Token: ;                    Type: SEMICOLON      
Token: j                    Type: IDENTIFIER     
Token: <                    Type: RELATIONAL_OP  
Token: 3                    Type: INTEGER_CONSTANT
Token: ;                    Type: SEMICOLON      
Token: j                    Type: IDENTIFIER     
Token: ++                   Type: POSTFIX_OP     
Token: )                    Type: RPAREN         
Token: {                    Type: LBRACE         
Token: if                   Type: KEYWORD        
Token: (                    Type: LPAREN         
Token: matrix               Type: IDENTIFIER     
Token: [                    Type: LBRACKET       
Token: i                    Type: IDENTIFIER     
Token: ]                    Type: RBRACKET       
Token: [                    Type: LBRACKET       
Token: j                    Type: IDENTIFIER     
Token: ]                    Type: RBRACKET       
Token: ==                   Type: RELATIONAL_OP  
Token: 5                    Type: INTEGER_CONSTANT
Token: )                    Type: RPAREN         
Token: {                    Type: LBRACE         
Token: continue             Type: KEYWORD        
Token: ;                    Type: SEMICOLON      
Token: }                    Type: RBRACE         
Token: if                   Type: KEYWORD        
Token: (                    Type: LPAREN         
Token: matrix               Type: IDENTIFIER     
Token: [                    Type: LBRACKET       
Token: i                    Type: IDENTIFIER     
Token: ]                    Type: RBRACKET       
Token: [                    Type: LBRACKET       
Token: j                    Type: IDENTIFIER     
Token: ]                    Type: RBRACKET       
Token: >                    Type: RELATIONAL_OP  
Token: 7                    Type: INTEGER_CONSTANT
Token: )                    Type: RPAREN         
Token: {                    Type: LBRACE         
Token: break                Type: KEYWORD        
Token: ;                    Type: SEMICOLON      
Token: }                    Type: RBRACE         
Token: sum                  Type: IDENTIFIER     
Token: +=                   Type: ASSIGN_OP      
Token: matrix               Type: IDENTIFIER     
Token: [                    Type: LBRACKET       
Token: i                    Type: IDENTIFIER     
Token: ]                    Type: RBRACKET       
Token: [                    Type: LBRACKET       
Token: j                    Type: IDENTIFIER     
Token: ]                    Type: RBRACKET       
Token: ;                    Type: SEMICOLON      
Token: }                    Type: RBRACE         
Token: }                    Type: RBRACE         
Token: printf               Type: IDENTIFIER     
Token: (                    Type: LPAREN         
Token: "Sum: %d\n"          Type: STRING_LITERAL 
Token: ,                    Type: COMMA          
Token: sum                  Type: IDENTIFIER     
Token: )                    Type: RPAREN         
Token: ;                    Type: SEMICOLON      
Token: return               Type: KEYWORD        
Token: 0                    Type: INTEGER_CONSTANT
Token: ;                    Type: SEMICOLON      
Token: }                    Type: RBRACE         

=== PARSING SUCCESSFUL ===

=== SEMANTIC ANALYSIS ===
=== SEMANTIC ANALYSIS STARTED ===
=== SEMANTIC ANALYSIS COMPLETED ===
Found 0 semantic error(s)
Found 0 warning(s)

=== SYMBOL TABLE (ACTIVE SCOPES) ===
Scope 0:
  function 'main' : int (scope: 0, line: 30) [has_return]
 (scope: 0, line: 30) [has_return]
  constant 'NULL' : void* (scope: 0, line: 0)
 (scope: 0, line: 0)

 Semantic analysis passed with no errors.

=== CODE GENERATION ===

=== THREE ADDRESS CODE ===
main:
    sum = 0
    i = 0
L0:
    t0 = i < 3
    ifFalse t0 goto L1
    j = 0
L3:
    t1 = j < 3
    ifFalse t1 goto L4
    t2 = i * 3
    t3 = t2 + j
    t4 = t3 + 1
    t5 = i * 3
    t6 = t5 + j
    t7 = t6 * 4
    t8 = &matrix
    t9 = t8 + t7
    *t9 = t4
L5:
    t10 = j
    j = j + 1
    goto L3
L4:
L2:
    t11 = i
    i = i + 1
    goto L0
L1:
    i = 0
L6:
    t12 = i < 3
    ifFalse t12 goto L7
    j = 0
L9:
    t13 = j < 3
    ifFalse t13 goto L10
    t14 = i * 3
    t15 = t14 + j
    t16 = t15 * 4
    t17 = &matrix
    t18 = t17 + t16
    t19 = *t18
    t20 = t19 == 5
    ifFalse t20 goto L12
    goto L11
L12:
    t21 = i * 3
    t22 = t21 + j
    t23 = t22 * 4
    t24 = &matrix
    t25 = t24 + t23
    t26 = *t25
    t27 = t26 > 7
    ifFalse t27 goto L14
    goto L10
L14:
    t28 = i * 3
    t29 = t28 + j
    t30 = t29 * 4
    t31 = &matrix
    t32 = t31 + t30
    t33 = *t32
    t34 = sum + t33
    sum = t34
L11:
    t35 = j
    j = j + 1
    goto L9
L10:
L8:
    t36 = i
    i = i + 1
    goto L6
L7:
    param "Sum: %d\n"
    param sum
    t37 = call printf, 2
    return 0

Total instructions: 79

=== ABSTRACT SYNTAX TREE ===
TranslationUnit :  (line 2)
  Preprocessor : #include <stdio.h> (line 2)
  FunctionDefinition :  (line 30)
    DeclarationSpecifiers :  (line 4)
      TypeSpecifier : int (line 4)
    FunctionDeclarator :  (line 4)
      DirectDeclarator : main (line 4)
    CompoundStatement :  (line 30)
      BlockItemList :  (line 5)
        BlockItem :  (line 5)
          Declaration :  (line 5)
            DeclarationSpecifiers :  (line 5)
              TypeSpecifier : int (line 5)
            InitDeclaratorList :  (line 5)
              InitDeclarator :  (line 5)
                ArrayDeclarator :  (line 5)
                  ArrayDeclarator :  (line 5)
                    DirectDeclarator : matrix (line 5)
                    Constant : 3 (line 5)
                  Constant : 3 (line 5)
        BlockItem :  (line 6)
          Declaration :  (line 6)
            DeclarationSpecifiers :  (line 6)
              TypeSpecifier : int (line 6)
            InitDeclaratorList :  (line 6)
              InitDeclarator :  (line 6)
                DirectDeclarator : sum (line 6)
                Initializer :  (line 6)
                  Constant : 0 (line 6)
        BlockItem :  (line 13)
          ForStatement :  (line 13)
            ForInitStatement :  (line 9)
              Declaration :  (line 9)
                DeclarationSpecifiers :  (line 9)
                  TypeSpecifier : int (line 9)
                InitDeclaratorList :  (line 9)
                  InitDeclarator :  (line 9)
                    DirectDeclarator : i (line 9)
                    Initializer :  (line 9)
                      Constant : 0 (line 9)
            ExpressionStatement :  (line 9)
              RelationalExpression : < (line 9)
                Identifier : i (line 9)
                Constant : 3 (line 9)
            PostfixExpression : ++ (line 9)
              Identifier : i (line 9)
            CompoundStatement :  (line 13)
              BlockItemList :  (line 12)
                BlockItem :  (line 12)
                  ForStatement :  (line 12)
                    ForInitStatement :  (line 10)
                      Declaration :  (line 10)
                        DeclarationSpecifiers :  (line 10)
                          TypeSpecifier : int (line 10)
                        InitDeclaratorList :  (line 10)
                          InitDeclarator :  (line 10)
                            DirectDeclarator : j (line 10)
                            Initializer :  (line 10)
                              Constant : 0 (line 10)
                    ExpressionStatement :  (line 10)
                      RelationalExpression : < (line 10)
                        Identifier : j (line 10)
                        Constant : 3 (line 10)
                    PostfixExpression : ++ (line 10)
                      Identifier : j (line 10)
                    CompoundStatement :  (line 12)
                      BlockItemList :  (line 11)
                        BlockItem :  (line 11)
                          ExpressionStatement :  (line 11)
                            AssignmentExpression : = (line 11)
                              ArraySubscript :  (line 11)
                                ArraySubscript :  (line 11)
                                  Identifier : matrix (line 11)
                                  Identifier : i (line 11)
                                Identifier : j (line 11)
                              AdditiveExpression : + (line 11)
                                AdditiveExpression : + (line 11)
                                  MultiplicativeExpression : * (line 11)
                                    Identifier : i (line 11)
                                    Constant : 3 (line 11)
                                  Identifier : j (line 11)
                                Constant : 1 (line 11)
        BlockItem :  (line 26)
          ForStatement :  (line 26)
            ForInitStatement :  (line 16)
              Declaration :  (line 16)
                DeclarationSpecifiers :  (line 16)
                  TypeSpecifier : int (line 16)
                InitDeclaratorList :  (line 16)
                  InitDeclarator :  (line 16)
                    DirectDeclarator : i (line 16)
                    Initializer :  (line 16)
                      Constant : 0 (line 16)
            ExpressionStatement :  (line 16)
              RelationalExpression : < (line 16)
                Identifier : i (line 16)
                Constant : 3 (line 16)
            PostfixExpression : ++ (line 16)
              Identifier : i (line 16)
            CompoundStatement :  (line 26)
              BlockItemList :  (line 25)
                BlockItem :  (line 25)
                  ForStatement :  (line 25)
                    ForInitStatement :  (line 17)
                      Declaration :  (line 17)
                        DeclarationSpecifiers :  (line 17)
                          TypeSpecifier : int (line 17)
                        InitDeclaratorList :  (line 17)
                          InitDeclarator :  (line 17)
                            DirectDeclarator : j (line 17)
                            Initializer :  (line 17)
                              Constant : 0 (line 17)
                    ExpressionStatement :  (line 17)
                      RelationalExpression : < (line 17)
                        Identifier : j (line 17)
                        Constant : 3 (line 17)
                    PostfixExpression : ++ (line 17)
                      Identifier : j (line 17)
                    CompoundStatement :  (line 25)
                      BlockItemList :  (line 21)
                        BlockItem :  (line 21)
                          IfStatement :  (line 21)
                            EqualityExpression : == (line 18)
                              ArraySubscript :  (line 18)
                                ArraySubscript :  (line 18)
                                  Identifier : matrix (line 18)
                                  Identifier : i (line 18)
                                Identifier : j (line 18)
                              Constant : 5 (line 18)
                            CompoundStatement :  (line 20)
                              BlockItemList :  (line 19)
                                BlockItem :  (line 19)
                                  ContinueStatement :  (line 19)
                        BlockItem :  (line 24)
                          IfStatement :  (line 24)
                            RelationalExpression : > (line 21)
                              ArraySubscript :  (line 21)
                                ArraySubscript :  (line 21)
                                  Identifier : matrix (line 21)
                                  Identifier : i (line 21)
                                Identifier : j (line 21)
                              Constant : 7 (line 21)
                            CompoundStatement :  (line 23)
                              BlockItemList :  (line 22)
                                BlockItem :  (line 22)
                                  BreakStatement :  (line 22)
                        BlockItem :  (line 24)
                          ExpressionStatement :  (line 24)
                            AssignmentExpression : += (line 24)
                              Identifier : sum (line 24)
                              ArraySubscript :  (line 24)
                                ArraySubscript :  (line 24)
                                  Identifier : matrix (line 24)
                                  Identifier : i (line 24)
                                Identifier : j (line 24)
        BlockItem :  (line 28)
          ExpressionStatement :  (line 28)
            FunctionCall :  (line 28)
              Identifier : printf (line 28)
              ArgumentList :  (line 28)
                StringLiteral : "Sum: %d\n" (line 28)
                Identifier : sum (line 28)
        BlockItem :  (line 29)
          ReturnStatement :  (line 29)
            Constant : 0 (line 29)

AST DOT file generated: ast.dot
TAC file generated: output.tac

=== MIPS ASSEMBLY GENERATION ===

=== MIPS ASSEMBLY CODE ===
    # ==============================================
    #   MIPS Assembly Code
    #   Generated from Three-Address Code
    # ==============================================

.data
.align 2
str_0: .asciiz "Sum: %d\n"
.align 2
newline: .asciiz "\n"
.align 2
matrix: .space 36

.text
.globl main


    # Function: main
main:
    # Reserve stack space for register spills
    addi $sp, $sp, -256
    li $t0, 0
    sw $t0, 0($sp)
    li $t0, 0
    sw $t0, 4($sp)
L0:
    # Reloading i from stack
    lw $t1, 4($sp)
    li $t2, 3
    slt $t0, $t1, $t2
    beq $t0, $zero, L1
    li $t0, 0
    sw $t0, 8($sp)
L3:
    # Reloading j from stack
    lw $t2, 8($sp)
    li $t3, 3
    slt $t0, $t2, $t3
    beq $t0, $zero, L4
    li $t3, 3
    mul $t0, $t1, $t3
    add $t3, $t0, $t2
    li $t4, 1
    add $t0, $t3, $t4
    li $t4, 3
    mul $t3, $t1, $t4
    add $t4, $t3, $t2
    li $t5, 4
    mul $t3, $t4, $t5
    la $t4, matrix
    add $t5, $t4, $t3
    sw $t0, 0($t5)
L5:
    move $t0, $t2
    li $t3, 1
    add $t2, $t2, $t3
    sw $t2, 8($sp)
    j L3
L4:
L2:
    move $t2, $t1
    li $t3, 1
    add $t1, $t1, $t3
    sw $t1, 4($sp)
    j L0
L1:
    # Reloading i from stack
    lw $t1, 4($sp)
    li $t1, 0
    sw $t1, 4($sp)
L6:
    # Reloading i from stack
    lw $t3, 4($sp)
    li $t4, 3
    slt $t1, $t3, $t4
    beq $t1, $zero, L7
    # Reloading j from stack
    lw $t1, 8($sp)
    li $t1, 0
    sw $t1, 8($sp)
L9:
    # Reloading j from stack
    lw $t4, 8($sp)
    li $t6, 3
    slt $t1, $t4, $t6
    beq $t1, $zero, L10
    li $t6, 3
    mul $t1, $t3, $t6
    add $t6, $t1, $t4
    li $t7, 4
    mul $t1, $t6, $t7
    la $t6, matrix
    add $t7, $t6, $t1
    lw $t1, 0($t7)
    li $t7, 5
    seq $t6, $t1, $t7
    beq $t6, $zero, L12
    j L11
L12:
    li $t6, 3
    mul $t1, $t3, $t6
    add $t6, $t1, $t4
    li $t7, 4
    mul $t1, $t6, $t7
    la $t6, matrix
    add $t7, $t6, $t1
    lw $t1, 0($t7)
    li $t7, 7
    sgt $t6, $t1, $t7
    beq $t6, $zero, L14
    j L10
L14:
    li $t6, 3
    mul $t1, $t3, $t6
    add $t6, $t1, $t4
    li $t7, 4
    mul $t1, $t6, $t7
    la $t6, matrix
    add $t7, $t6, $t1
    lw $t1, 0($t7)
    # Reloading sum from stack
    lw $t7, 0($sp)
    add $t6, $t7, $t1
    move $t7, $t6
    sw $t7, 0($sp)
L11:
    move $t1, $t4
    li $t6, 1
    add $t4, $t4, $t6
    sw $t4, 8($sp)
    j L9
L10:
L8:
    move $t4, $t3
    li $t6, 1
    add $t3, $t3, $t6
    sw $t3, 4($sp)
    j L6
L7:
    la $s0, str_0
    # Save string param str_0 to $s0
    # Reloading sum from stack
    lw $t3, 0($sp)
    move $s1, $t3
    # Save param sum to $s1
    # Call printf
    li $v0, 11
    li $a0, 83
    syscall
    li $v0, 11
    li $a0, 117
    syscall
    li $v0, 11
    li $a0, 109
    syscall
    li $v0, 11
    li $a0, 58
    syscall
    li $v0, 11
    li $a0, 32
    syscall
    # Print integer
    li $v0, 1
    move $a0, $s1
    syscall
    li $v0, 11
    li $a0, 10
    syscall
    li $v0, 0
    # Restore stack and exit program
    addi $sp, $sp, 256
    li $v0, 10
    syscall

MIPS file generated: output.s

==================================================
COMPILATION SUCCESSFUL
==================================================
